<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Samoussa Runner - WAYOWAYO</title>
    <style>
        * {
            box-sizing: border-box;
            touch-action: manipulation;
        }
        html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
}
        body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: #f5f5f5;
    font-family: 'Arial', sans-serif;
    overflow: hidden;
    width: 100%;
    height: 100%;
}
        #game-container {
    position: relative;
    width: 100%;
    max-width: 800px;
    height: 100vh;
    max-height: none; /* Supprimer la restriction de hauteur */
    overflow: hidden;
    border: none;
    border-radius: 0;
    box-shadow: none;
    background: linear-gradient(to bottom, #87CEEB, #E0F7FA 70%, #bda79d 95%, #8B4513);
    z-index: 0;
}
        
        /* Logo WAYOWAYO */
        #logo-game {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px;
            height: auto;
            z-index: 5;
            opacity: 0.8;
        }
        
        /* Montagne estomp√©e en arri√®re-plan - plus visible */
        .montagne {
            position: absolute;
            width: 100%;
            height: 25%;
            bottom: 15%;
            z-index: 1;
            overflow: hidden;
        }
        
        .montagne-forme {
            position: absolute;
            width: 300px;
            height: 120px;
            background: linear-gradient(to bottom, rgba(130, 145, 160, 0.5), rgba(130, 145, 160, 0));
            border-radius: 50% 50% 0 0;
            transform: scaleX(3);
        }
        
        .montagne-forme-1 {
            left: -5%;
            bottom: 0;
            height: 90px;
        }
        
        .montagne-forme-2 {
            left: 30%;
            bottom: 0;
            height: 110px;
            opacity: 0.7;
        }
        
        .montagne-forme-3 {
            left: 65%;
            bottom: 0;
            height: 80px;
            opacity: 0.8;
        }
        
        /* Nuages d√©coratifs */
        .cloud {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 50%;
            z-index: 1;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            filter: blur(1px);
        }
        
        /* √âl√©ments d√©coratifs cr√©oles */
        .creole-element {
            position: absolute;
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        
       /* REMPLACER TOUT LE CODE DES COCOTIERS PAR CELUI-CI */
.cocotier {
    /* Remplacez tout ce qui est ici */
    position: absolute;
    z-index: 2;
    opacity: 0.9;
    bottom: 15%;
    width: 60px;
    height: 170px;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}

.cocotier-tronc {
    /* Remplacez tout ce qui est ici */
    position: absolute;
    width: 10px;
    height: 100px;
    background: linear-gradient(to top, #8B5A2B, #A0522D);
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%) rotate(5deg);
    border-radius: 4px;
    z-index: 2;
}

.cocotier-feuilles {
    /* Remplacez tout ce qui est ici */
    position: absolute;
    bottom: 45px;
    left: -5%;
    transform: translateX(-50%) rotate(64deg);
    width: 150%;
    height: 80px;
    z-index: 3;
    pointer-events: none;
    will-change: transform;
}

.cocotier-feuille {
    position: absolute;
    width: 75px;
    height: 14px;
    background-color: #3CB371;
    border-radius: 100% 30% 100% 30% / 50%;
    transform-origin: right center;
    box-shadow: 0 2px 3px rgba(0,0,0,0.25);
    filter: drop-shadow(0 0 1px rgba(0,100,0,0.2));
    z-index: 3;
    pointer-events: none;
}

/* Position des feuilles individuelles inchang√©e */
.cocotier-feuille:nth-child(1) {
    transform: rotate(-15deg) translateX(-15px);
    top: 0;
    left: -5px;
}

.cocotier-feuille:nth-child(2) {
    transform: rotate(15deg) translateX(-15px);
    top: 0;
    left: -5px;
}

.cocotier-feuille:nth-child(3) {
    transform: rotate(-40deg) translateX(-12px);
    top: 0;
    left: -8px;
}

.cocotier-feuille:nth-child(4) {
    transform: rotate(40deg) translateX(-12px);
    top: 0;
    left: -8px;
}

.cocotier-feuille:nth-child(5) {
    transform: rotate(-65deg) translateX(-8px);
    top: 0;
    left: -10px;
}

.cocotier-feuille:nth-child(6) {
    transform: rotate(65deg) translateX(-8px);
    top: 0;
    left: -10px;
}

.cocotier-feuille:nth-child(7) {
    transform: rotate(-90deg) translateX(-4px);
    top: 0;
    left: -12px;
}

.cocotier-feuille:nth-child(8) {
    transform: rotate(90deg) translateX(-4px);
    top: 0;
    left: -12px;
}

/* GROUPE DE NOIX DE COCO */
.cocotier-noix {
    position: absolute;
    bottom: 85px;
    left: 50%;
    transform: translateX(-50%);
    width: 12px;
    height: 12px;
    background-color: #654321;
    border-radius: 50%;
    box-shadow: inset 1px -1px 3px rgba(255,255,255,0.3);
    z-index: 4; /* Sup√©rieur au z-index des feuilles (3) */
}

.cocotier-noix-gauche {
    position: absolute;
    bottom: 80px;
    left: 40%;
    width: 10px;
    height: 10px;
    background-color: #654321;
    border-radius: 50%;
    box-shadow: inset 1px -1px 3px rgba(255,255,255,0.3);
    z-index: 4; /* Sup√©rieur au z-index des feuilles (3) */
}

.cocotier-noix-droite {
    position: absolute;
    bottom: 82px;
    left: 60%;
    width: 11px;
    height: 11px;
    background-color: #654321;
    border-radius: 50%;
    box-shadow: inset 1px -1px 3px rgba(255,255,255,0.3);
    z-index: 4; /* Sup√©rieur au z-index des feuilles (3) */
}

        /* Case cr√©ole am√©lior√©e */
        .case-creole {
    position: absolute;
    width: 100px; /* Augment√© de 80px √† 100px */
    height: 65px; /* Augment√© de 50px √† 65px */
    z-index: 2;
    bottom: 15%; /* Alignement avec le sol */
}

        .case-mur {
    position: absolute;
    width: 100%;
    height: 68%; /* Augment√© l√©g√®rement de 65% √† 68% */
    bottom: -3px; /* D√©calage n√©gatif de 2px pour d√©passer sous la case */
    background-color: #f9e4b7;
    border: 1px solid #654321;
    border-radius: 2px;
}

        .case-toit {
            position: absolute;
            width: 110%;
            height: 50%;
            top: -15%;
            left: -5%;
            background-color: #8B4513;
            clip-path: polygon(0 100%, 50% 0, 100% 100%);
            border-radius: 2px;
        }

        .case-porte {
    position: absolute;
    width: 25px;
    height: 28px;
    bottom: -3px; /* D√©calage n√©gatif de 2px pour d√©passer sous la case */
    left: 50%;
    transform: translateX(-50%);
    background-color: #8B4513;
    border-radius: 2px 2px 0 0;
}

        .case-volet {
            position: absolute;
            width: 14px;
            height: 22px;
            background-color: #5272a1;
            border: 1px solid #444;
            border-radius: 1px;
            top: 30px;
        }

        .case-volet-gauche {
            left: 15px;
        }

        .case-volet-droite {
            right: 15px;
        }

        /* Motif en Z pour les volets */
        .case-volet::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 15%;
            top: 10%;
            left: 0;
            background-color: white;
        }

        .case-volet::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 15%;
            bottom: 10%;
            left: 0;
            background-color: white;
        }

        .case-volet-z {
            position: absolute;
            width: 140%;
            height: 15%;
            top: 42%;
            left: -20%;
            background-color: white;
            transform: rotate(32deg);
        }

        /* Ajuster l'√©chelle selon la taille de l'√©cran */
        @media (max-width: 767px) {
            .cocotier {
                transform: scale(0.9);
            }
            
            .case-creole {
                transform: scale(0.9);
            }
        }

        /* R√©duire la hauteur du sol pour le remonter */
#ground {
    position: absolute;
    width: 100%;
    height: 30%;
    bottom: 0;
    background-color: rgba(141, 110, 99, 0.7);
    background-image: 
        linear-gradient(90deg, rgba(120, 90, 80, 0.15) 50%, transparent 50%),
        linear-gradient(rgba(120, 90, 80, 0.3) 1px, transparent 1px);
    background-size: 20px 100%, 100% 8px;
    box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.2);
    z-index: 2;
}

        #samoussa {
            position: absolute;
            width: 18%;  /* Augment√© significativement pour mobile */
            max-width: 100px;
            aspect-ratio: 1/1;
            bottom: 15%;
            left: 15%;
            z-index: 5;
            /* Style pour l'√©l√©ment visuel */
            background-image: url('assets/samoussa_run1.png');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        /* Hitbox pour le samoussa */
        #samoussa::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 70%;
            top: 15%;
            left: 15%;
            border-radius: 35%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .obstacle {
            position: absolute;
            width: 16%;  /* Augment√© significativement pour mobile */
            max-width: 80px;
            aspect-ratio: 1/1;
            bottom: 15%;
            z-index: 4;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .obstacle.couteau {
            background-image: url('assets/couteau.png');
        }
        
        .obstacle.couteau::after {
            content: '';
            position: absolute;
            width: 60%;
            height: 70%;
            top: 15%;
            left: 20%;
            clip-path: polygon(0% 20%, 50% 100%, 100% 20%, 80% 0%, 20% 0%);
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .obstacle.marmite {
            background-image: url('assets/marmite.png');
        }
        
        .obstacle.marmite::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            top: 15%;
            left: 10%;
            border-radius: 50% 50% 20% 20%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .obstacle.main {
            background-image: url('assets/main.png');
        }
        
        .obstacle.main::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 90%;
            top: 5%;
            left: 15%;
            border-radius: 30% 30% 10% 10%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .collectible {
            position: absolute;
            width: 14%;  /* Augment√© significativement pour mobile */
            max-width: 60px;
            aspect-ratio: 1/1;
            z-index: 4;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .collectible.piment {
            background-image: url('assets/piment.png');
        }
        
        .collectible.piment::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 70%;
            top: 15%;
            left: 15%;
            border-radius: 50% 15% 50% 15%;
            transform: rotate(45deg);
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .collectible.epice {
            background-image: url('assets/epice.png');
        }
        
        .collectible.epice::after {
            content: '';
            position: absolute;
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
            border-radius: 10px;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .collectible.biere {
            background-image: url('assets/biere_dodo.png');
            aspect-ratio: 5/6;
        }
        
        .collectible.biere::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 80%;
            top: 10%;
            left: 15%;
            border-radius: 20% 20% 5% 5%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        /* Fallbacks en cas de probl√®me de chargement */
        .fallback-mode #samoussa {
            background-image: none;
            background-color: #f3c669;
            border-radius: 35%;
        }
        
        .fallback-mode .obstacle.couteau {
            background-image: none;
            background-color: #a1a1a1;
            clip-path: polygon(0% 20%, 50% 100%, 100% 20%, 80% 0%, 20% 0%);
        }
        
        .fallback-mode .obstacle.marmite {
            background-image: none;
            background-color: #505050;
            border-radius: 50% 50% 10% 10%;
        }
        
        .fallback-mode .obstacle.main {
            background-image: none;
            background-color: #ffcba4;
            border-radius: 30% 30% 10% 10%;
        }
        
        .fallback-mode .collectible.piment {
            background-image: none;
            background-color: #ff3b30;
            border-radius: 50% 15% 50% 15%;
            transform: rotate(45deg);
        }
        
        .fallback-mode .collectible.epice {
            background-image: none;
            background-color: #ff9500;
            border-radius: 5px;
        }
        
        .fallback-mode .collectible.biere {
            background-image: none;
            background-color: #ffd700;
            border-radius: 20% 20% 5% 5%;
        }

        #score-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 4vmin;
            font-weight: bold;
            z-index: 10;
        }

        .status-effect {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 165, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 4vmin;
            font-weight: bold;
            z-index: 10;
            display: none;
        }

        .overlay-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.75));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }

        .logo-container {
            margin-bottom: 15px;
            max-width: 100%;
            padding: 0 10px;
        }
        
        #logo-accueil {
            width: 75%;
            max-width: 250px;
            height: auto;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.4));
            margin-top: -20px; /* Repositionn√© plus haut pour √™tre enti√®rement visible */
        }
        
        .combo-explanation {
            background-color: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 8px 15px;
            margin: 10px 0;
            font-size: 3vmin;
            max-width: 90%;
        }
        
        .combo-explanation strong {
            color: #FFD700;
            display: block;
            margin-bottom: 5px;
        }
        
        .combo-explanation p {
            margin: 5px 0;
        }
        
        @keyframes pulse-glow {
            0% { text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5); }
            50% { text-shadow: 0 0 10px rgba(255, 215, 0, 0.7), 0 0 20px rgba(255, 215, 0, 0.4); }
            100% { text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5); }
        }

        .btn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 5vmin;
            background-color: #ff6b6b;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 2000;
            position: relative;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover, .btn:active {
            background-color: #ff8c8c;
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .restaurant-info {
            width: 100%;
            font-size: 3vmin;
            color: white;
            text-align: center;
            margin-top: 30px;
            padding: 10px;
            background-color: rgba(255, 107, 107, 0.2);
            border-radius: 8px;
        }
        
        .restaurant-info p:last-child {
            font-style: italic;
            color: #FFD700;
        }

        .invisible {
            opacity: 0.5;
        }
        
       .power-indicator {
    position: absolute;
    bottom: 18%; /* R√©duit de 25% √† 18% pour l'abaisser un peu */
    left: 50%;
    transform: translateX(-50%);
    height: 10px;
    width: 50%;
    background-color: #333;
    border-radius: 5px;
    overflow: hidden;
    z-index: 100;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.15);
}
        
        .power-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
    transition: width 0.1s;
    box-shadow: inset 0 0 5px rgba(255,255,255,0.3);
}
        
        #combo-container {
            position: absolute;
            top: 60px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.6);
            padding: 10px;
            border-radius: 5px;
            font-size: 4vmin;
            font-weight: bold;
            color: #ff6b6b;
            z-index: 10;
            display: none;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .combo-pulse {
            animation: pulse 0.5s ease-in-out;
        }
        
        .collect-effect {
            position: absolute;
            color: #FFEB3B;
            font-weight: bold;
            font-size: 4vmin;
            z-index: 5;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s, opacity 0.5s;
        }
        
        #highscores {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 35%;
            max-width: 200px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 3vmin;
            z-index: 10;
        }
        
        #highscores h3 {
            margin: 0 0 10px 0;
            text-align: center;
            color: #ff6b6b;
            font-size: 3.5vmin;
        }
        
        #highscores ol {
            margin: 0;
            padding-left: 25px;
        }
        
        #highscores li {
            margin-bottom: 5px;
        }
        
        .share-buttons {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            gap: 10px;
        }
        
        .share-button {
            display: inline-block;
            padding: 12px 18px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 3.5vmin;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            margin: 0 5px;
            user-select: none;
            -webkit-tap-highlight-color: transparent; /* Supprime le surlignage sur tactile */
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .share-button:active {
            transform: scale(0.95);
        }

        .share-x {
            background-color: #000000;
        }
        
        .share-whatsapp {
            background-color: #25D366;
        }
        
        .share-sms {
            background-color: #3B82F6;
        }
        
        /* Effet de boost am√©lior√© */
        .boost-effect {
            position: absolute;
            width: 150px;
            height: 60px;
            background: radial-gradient(ellipse at center, rgba(255, 165, 0, 0.7), rgba(255, 165, 0, 0) 70%);
            border-radius: 50%;
            z-index: 2;
            pointer-events: none;
            display: none;
            transform: translateX(-50%);
            animation: boost-pulse 0.8s infinite alternate;
        }
        
        @keyframes boost-pulse {
            0% { transform: translateX(-50%) scale(1); opacity: 0.7; }
            100% { transform: translateX(-50%) scale(1.2); opacity: 0.5; }
        }
        
        .overlay-screen > * {
            max-width: 90%;
            margin-left: auto;
            margin-right: auto;
        }
        
        #instructions {
            font-size: 3.5vmin;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            max-width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #instructions p {
            margin: 8px 0;
        }
        
        #instructions strong {
            color: #FFD700;
        }
        
        #jump-hint {
    position: absolute;
    bottom: 50%; /* Augmenter de 25% √† 50% pour le placer bien au-dessus du samoussa */
    left: 50%;
    transform: translateX(-50%);
    color: white;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 10px 15px;
    border-radius: 8px;
    font-size: 3.5vmin;
    z-index: 20;
    display: none;
    text-align: center;
    max-width: 80%;
    box-shadow: 0 3px 6px rgba(0,0,0,0.3);
}
        
        .hint-detail {
            font-size: 3vmin;
            display: block;
            margin-top: 5px;
            color: #FFD700;
            opacity: 0.9;
        }
        
        @media (orientation: landscape) {
            #game-container {
                height: 85vh;
                max-height: 500px;
            }
        }
        
        @media (max-height: 500px) {
            .restaurant-info {
                font-size: 2.5vmin;
                margin-top: 15px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 4vmin;
                margin-top: 10px;
            }
        }
        
        /* Animation nuages */
        @keyframes float-cloud {
            0% { transform: translateX(120%); }
            100% { transform: translateX(-120%); }
        }
        
        /* Animation volets */
        @keyframes sway {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(2deg); }
            100% { transform: rotate(0deg); }
        }
        
        /* Ajouter une classe de debug pour visualiser les hitboxes */
        .debug-mode .obstacle::after,
        .debug-mode .collectible::after,
        .debug-mode #samoussa::after {
            background-color: rgba(255, 0, 0, 0.5) !important;
        }
        /* Styles pour la section de r√©compense */
.reward-section {
    background-color: rgba(255, 215, 0, 0.2);
    border: 2px solid #FFD700;
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    animation: glow 1.5s infinite alternate;
    max-width: 90%;
}

.qr-container {
    background-color: white;
    padding: 10px;
    border-radius: 8px;
    display: inline-block;
    margin: 10px 0;
}

.reward-title {
    color: #FFD700;
    margin-bottom: 5px;
    font-size: 5vmin;
}

.reward-text {
    color: white;
    font-size: 4vmin;
    margin: 5px 0;
}

.code-text {
    font-family: monospace;
    font-size: 3.5vmin;
    background: rgba(0,0,0,0.7);
    padding: 5px;
    border-radius: 5px;
    display: inline-block;
    margin-top: 5px;
}

.expiry {
    font-size: 3vmin;
    color: #FF9800;
    margin-top: 8px;
}
        /* Styles sp√©cifiques pour le message desktop */
#desktop-message h2 {
    color: #FF5722;
    margin-bottom: 20px;
    animation: pulse 1.5s infinite alternate;
}

#desktop-message p {
    font-size: 4.5vmin;
    max-width: 80%;
    margin: 10px auto;
}

#desktop-message img {
    margin-bottom: 30px;
}
        /* Ajoutez le nouveau style juste ici */
.screenshot-hint {
    margin-top: 10px;
    font-weight: bold;
    color: #FFD700;
    font-size: 3.5vmin;
    animation: pulse 1.5s infinite alternate;
}

@keyframes glow {
    from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
    to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
}
        /* Styles pour le paille-en-queue */
.paille-en-queue {
    position: absolute;
    top: 25%; /* Modifi√© de 10% √† 25% */
    left: -80px;
    width: 60px;
    height: 22px;
    z-index: 3;
    animation: vol-oiseau 25s linear infinite;
    pointer-events: none;
}

.paille-corps {
    position: absolute;
    width: 32px;
    height: 12px;
    background-color: white;
    border-radius: 50% 60% 60% 40%;
    top: 5px;
    left: 0;
}

.paille-tete {
    position: absolute;
    width: 12px;
    height: 10px;
    background-color: white;
    border-radius: 50%;
    top: 4px;
    left: 30px;
}

.paille-bec {
    position: absolute;
    width: 10px;
    height: 4px;
    background-color: #FFCC00;
    border-radius: 0 50% 50% 0;
    top: 7px;
    left: 41px;
}

.paille-aile {
    position: absolute;
    width: 36px;
    height: 8px;
    background-color: white;
    border-radius: 70% 30% 90% 10%; /* Inverser la courbure */
    transform-origin: 80% 50%; /* Changer l'origine de transformation vers l'arri√®re */
    animation: battement-ailes 2s infinite alternate ease-in-out;
}


.paille-aile-haute {
    top: 2px;
    left: 8px;
    transform: rotate(-8deg);
}

.paille-aile-basse {
    top: 12px;
    left: 8px;
    transform: rotate(8deg);
}

.paille-aile::after {
    content: '';
    position: absolute;
    width: 12px;
    height: 3px;
    background-color: #333;
    left: 4px; /* D√©placer √† gauche au lieu de droite */
    top: 3px;
    border-radius: 2px;
    opacity: 0.8;
}
        
.paille-queue {
    position: absolute;
    width: 70px;
    height: 3px;
    background-color: white;
    border-radius: 2px;
    top: 10px;
    left: -50px;
    transform-origin: right center;
    animation: ondulation-queue 3s infinite alternate ease-in-out;
}

@keyframes vol-oiseau {
    0% {
        left: -80px;
        top: 25%; /* Abaiss√© de 15% √† 25% */
    }
    40% {
        top: 22%; /* Abaiss√© de 8% √† 22% */
    }
    50% {
        top: 23%; /* Abaiss√© de 12% √† 23% */
    }
    100% {
        left: calc(100% + 80px);
        top: 25%; /* Abaiss√© de 10% √† 25% */
    }
}

@keyframes battement-ailes {
    0% {
        transform: rotate(8deg); /* Angle invers√© */
    }
    100% {
        transform: rotate(15deg); /* Angle invers√© */
    }
}

.paille-aile-basse {
    animation-name: battement-ailes-bas;
}

@keyframes battement-ailes-bas {
    0% {
        transform: rotate(-8deg); /* Angle invers√© */
    }
    100% {
        transform: rotate(-15deg); /* Angle invers√© */
    }
}

@keyframes ondulation-queue {
    0% {
        transform: rotate(0deg);
    }
    50% {
        transform: rotate(2deg);
    }
    100% {
        transform: rotate(-2deg);
    }
}
        #audio-controls {
    position: absolute;
    top: 130px; /* Position bien en-dessous du combo */
    left: 20px; /* M√™me alignement que le score */
    z-index: 150; /* z-index tr√®s √©lev√© pour √™tre s√ªr qu'il est au-dessus de tout */
    cursor: pointer;
    background-color: rgba(255, 255, 255, 0.8); /* Fond plus opaque */
    padding: 8px;
    border-radius: 8px;
    width: 44px;
    height: 44px;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Ombre pour mieux se d√©tacher */
    -webkit-tap-highlight-color: transparent; /* Supprime le surlignage au toucher sur iOS */
}

#sound-icon {
    width: 32px;
    height: 32px;
    filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
}
/* Modifications pour l'√©cran Game Over */
#game-over {
    justify-content: flex-start; /* Aligner depuis le haut au lieu de centrer */
    padding-top: 10vh; /* Espace en haut de l'√©cran */
}

/* Logo container plus compact */
#game-over .logo-container {
    margin-bottom: 5px; /* R√©duit de 15px √† 5px */
    transform: scale(0.85); /* R√©duire l√©g√®rement la taille */
}

/* Titres et textes plus compacts */
#game-over h2 {
    margin: 10px 0; /* R√©duit les marges */
    font-size: 8vmin; /* Taille relative plus grande */
}

/* Regrouper les informations de score dans un container */
#game-over .score-info {
    display: flex;
    flex-direction: column;
    gap: 8px; /* Espace entre les lignes */
    margin: 5px 0 15px 0; /* Marges r√©duites */
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    width: 85%;
}

#game-over .score-info p {
    margin: 0; /* Supprimer marges par d√©faut */
    font-size: 5vmin; /* Taille relative √† la largeur de l'√©cran */
}

/* Boutons de partage plus compacts */
#game-over .share-buttons {
    margin-top: 10px; /* R√©duit de 20px √† 10px */
}

/* Section de meilleurs scores plus compacte */
#game-over .reward-section {
    margin: 10px 0; /* R√©duit de 15px √† 10px */
    padding: 10px; /* R√©duit de 15px √† 10px */
    max-width: 85%; /* L√©g√®rement plus √©troit */
}

/* Pied de page plus compact */
#game-over .restaurant-info {
    margin-top: 10px; /* R√©duit de 30px √† 10px */
    font-size: 2.8vmin; /* L√©g√®rement plus petit */
}

/* Cacher le combo si demand√© */
#final-combo-container {
    display: none;
}

/* Ajustements pour les grands √©crans (comme l'iPhone 15) */
@media screen and (min-height: 800px) {
    #game-over {
        padding-top: 8vh; /* Un peu moins d'espace en haut */
    }
    
    #game-over .score-info {
        gap: 12px; /* Plus d'espace entre les lignes */
    }
    
    #game-over .logo-container {
        margin-bottom: 10px; /* Un peu plus d'espace */
    }
}
        /* Ajustements Safari pour l'√©cran Game Over */
@supports (-webkit-touch-callout: none) {
    /* CSS sp√©cifique pour Safari iOS */
    #game-over {
        padding-bottom: 100px; /* Espace suppl√©mentaire en bas pour Safari */
        overflow-y: auto; /* Permettre le d√©filement si n√©cessaire */
        -webkit-overflow-scrolling: touch; /* D√©filement doux pour iOS */
    }
    
    /* R√©duire encore la taille de certains √©l√©ments */
    #game-over .logo-container {
        transform: scale(0.8);
        margin-bottom: 0;
    }
    
    #game-over h2 {
        margin: 5px 0;
        font-size: 7vmin;
    }
    
    #game-over .score-info {
        margin: 0 0 10px 0;
        padding: 8px;
    }
    
    /* R√©duire la marge des boutons de partage */
    #game-over .share-buttons {
        margin-top: 5px;
        gap: 5px;
    }
    
    /* Ajustements pour la section des meilleurs scores */
    #game-over .reward-section {
        padding: 8px;
        margin: 5px 0;
    }
    
    /* Ajouter un message PWA pour Safari */
    #safari-pwa-prompt {
        display: block;
        font-size: 2.5vmin;
        color: #FFD700;
        margin: 5px 0;
        padding: 3px 8px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 5px;
        width: 80%;
        text-align: center;
    }
    
    /* S'assurer que le bouton Rejouer est bien visible */
    #restart-button {
        margin-top: 8px;
        padding: 12px 25px;
    }
    
    /* Ajuster la zone d'info restaurant */
    .restaurant-info {
        margin-top: 5px;
        padding: 5px;
    }
}

/* R√©duire la taille pour les tr√®s petits √©crans en hauteur (iPhone SE en paysage, etc.) */
@media screen and (max-height: 400px) {
    #game-over h2 {
        font-size: 6vmin;
        margin: 2px 0;
    }
    
    #game-over .score-info {
        gap: 4px;
        padding: 5px;
    }
    
    .share-button {
        padding: 8px 12px;
        font-size: 3vmin;
    }
    
    #restart-button {
        padding: 8px 20px;
        margin-top: 5px;
    }
}
  /* Styles pour le formulaire d'email */
.email-form-container {
   width: 85%;
    margin: 8px auto; /* Chang√© de 8px 0 √† 8px auto pour centrer */
    text-align: center; /* Centrer le contenu */
}

.email-button {
    display: inline-block;
    background-color: #4A89DC;
    color: white;
    padding: 8px 15px;
    border-radius: 8px;
    font-size: 3.5vmin;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    transition: all 0.2s ease;
    text-align: center;
    margin: 0 auto 8px auto; /* Centr√© horizontalement */
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    border: none;
    width: 85%;
    font-weight: bold;
}

.email-button:active {
    transform: scale(0.95);
    box-shadow: 0 1px 2px rgba(0,0,0,0.3);
}

.email-form {
    background-color: rgba(0,0,0,0.3);
    border-radius: 8px;
    padding: 10px;
    margin-top: 5px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

.email-form input[type="email"] {
    padding: 8px 12px;
    border-radius: 6px;
    border: none;
    font-size: 3.5vmin;
    background-color: rgba(255,255,255,0.9);
}

.email-form button {
    padding: 8px 15px;
    border-radius: 6px;
    border: none;
    background-color: #4A89DC;
    color: white;
    font-size: 3.5vmin;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.2s;
}

.email-form button:active {
    background-color: #3D7BCC;
}

.email-status {
    font-size: 3vmin;
    text-align: center;
    padding: 5px;
    border-radius: 4px;
    display: none;
}

.email-status.success {
    display: block;
    background-color: rgba(39, 174, 96, 0.3);
    color: #2ecc71;
}

.email-status.error {
    display: block;
    background-color: rgba(231, 76, 60, 0.3);
    color: #e74c3c;
}

.email-status.loading {
    display: block;
    color: #f39c12;
    background-color: rgba(243, 156, 18, 0.2);
}

/* Adaptation pour √©crans plus petits */
@media (max-height: 600px) {
    .email-button {
        padding: 6px 12px;
        font-size: 3vmin;
    }
    
    .email-form {
        padding: 8px;
        gap: 6px;
    }
    
    .email-form input[type="email"],
    .email-form button {
        padding: 6px 10px;
        font-size: 3vmin;
    }
}      
    </style>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <!-- Ajoutez ces lignes dans la section <head> -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#ff6b6b">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Samoussa Runner">
<link rel="apple-touch-icon" href="icons/icon-152x152.png">

<!-- Liens pour les ic√¥nes iOS -->
<link rel="apple-touch-icon" sizes="72x72" href="ios/72.png">
<link rel="apple-touch-icon" sizes="96x96" href="ios/96.png">
<link rel="apple-touch-icon" sizes="128x128" href="ios/128.png">
<link rel="apple-touch-icon" sizes="144x144" href="ios/144.png">
<link rel="apple-touch-icon" sizes="152x152" href="ios/152.png">
<link rel="apple-touch-icon" sizes="192x192" href="ios/192.png">
<link rel="apple-touch-icon" sizes="384x384" href="ios/384.png">
<link rel="apple-touch-icon" sizes="512x512" href="ios/512.png">
</head>
<body>
    <div id="game-container">
        <div id="audio-controls">
    <img id="sound-icon" src="assets/sound-on.png" alt="Son activ√©" style="width: 30px; height: 30px; filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));">
</div>
                    <!-- Logo WAYOWAYO avec position optimis√©e -->
        <img id="logo-game" src="assets/ww.png" alt="WAYOWAYO" style="opacity: 0.95; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2))">
        
        <!-- Montagne estomp√©e en arri√®re-plan -->
        <div class="montagne">
            <div class="montagne-forme montagne-forme-1"></div>
            <div class="montagne-forme montagne-forme-2"></div>
            <div class="montagne-forme montagne-forme-3"></div>
        </div>
        
        <div id="ground"></div>
        <div id="samoussa"></div>
        <div id="score-container">Score: <span id="score">0</span></div>
        <div id="combo-container">Combo: <span id="combo-count">x1</span></div>
        <div class="status-effect" id="invisibility-effect">Invisibilit√©: <span id="invisibility-time">0</span>s</div>
        <div class="boost-effect" id="boost-effect"></div>
        
        <!-- Tableau des meilleurs scores -->
        <div id="highscores">
            <h3>Meilleurs scores</h3>
            <ol id="highscore-list">
                <li>---</li>
                <li>---</li>
                <li>---</li>
                <li>---</li>
                <li>---</li>
            </ol>
        </div>
        
        <!-- Indicateur de saut pour appareils tactiles -->
        <div id="jump-hint">Tapez pour sauter !<br><span class="hint-detail">Appuyez longtemps pour sauter plus haut</span></div>
    </div>
    
    <!-- √âcrans d√©tach√©s -->
    <div id="start-screen" class="overlay-screen">
        <div class="logo-container">
            <img id="logo-accueil" src="assets/ww.png" alt="WAYOWAYO" />
        </div>
        <h2>Samoussa Runner</h2>
        <p>Aidez le samoussa √† √©viter les obstacles et √† collecter les √©pices !</p>
        <p id="dodo-info" style="color: #FFD700; font-weight: bold; font-size: 4.2vmin; margin: 5px 0;">La bi√®re Dodo te rend momentan√©ment invincible!</p>
        
        <div id="instructions">
            <p>Sur mobile: <strong>Tapez sur l'√©cran</strong> pour sauter</p>
            <p>Sur ordinateur: <strong>ESPACE</strong> pour sauter</p>
            <p>Maintenez appuy√© pour sauter plus haut!</p>
        </div>
        <button class="btn" id="start-button">JOUER</button>
        <div class="restaurant-info">
            <p>Restaurant Cr√©ole R√©unionnais WAYOWAYO</p>
            <p>Venez d√©guster nos d√©licieux samoussas!</p>
        </div>
    </div>
    <div id="game-over" class="overlay-screen" style="display: none;">
    <div class="logo-container">
        <img id="logo-game-over" src="assets/ww.png" alt="WAYOWAYO" style="width: 60%; max-width: 200px;" />
    </div>
    <h2>GAME OVER</h2>
    
    <!-- Nouveau container pour regrouper les infos de score -->
    <div class="score-info">
        <p>Score final: <span id="final-score">0</span></p>
        <!-- Le combo est maintenant optionnel et cach√© par d√©faut -->
        <p id="final-combo-container">Meilleur combo: <span id="final-combo">x1</span></p>
        <p>Niveau atteint: <span id="final-level">1</span></p>
    </div>
    
    <!-- Boutons de partage -->
    <div class="share-buttons">
        <div class="share-button share-x" id="share-x-btn">X</div>
        <div class="share-button share-whatsapp" id="share-whatsapp-btn">WhatsApp</div>
        <div class="share-button share-sms" id="share-sms-btn">SMS</div>
    </div>
    <div id="safari-pwa-prompt" style="display: none;">
    Pour une meilleure exp√©rience, ajoutez ce jeu √† l'√©cran d'accueil üì±
</div>
    <button class="btn" id="restart-button">REJOUER</button>
    <div class="restaurant-info">
        <p>Restaurant Cr√©ole R√©unionnais WAYOWAYO</p>
        <p>Venez d√©guster nos d√©licieux samoussas!</p>
    </div>
</div>
    
    <div id="desktop-message" class="overlay-screen" style="display: none;">
        <div class="logo-container">
            <img id="logo-desktop" src="assets/ww.png" alt="WAYOWAYO" style="width: 60%; max-width: 200px;" />
        </div>
        <h2>VERSION MOBILE UNIQUEMENT</h2>
        <p>Ce jeu est con√ßu exclusivement pour les appareils mobiles.</p>
        <p>Veuillez y acc√©der depuis votre smartphone ou tablette pour jouer √† Samoussa Runner.</p>
        <div class="restaurant-info">
            <p>Restaurant Cr√©ole R√©unionnais WAYOWAYO</p>
            <p>Venez d√©guster nos d√©licieux samoussas!</p>
        </div>
    </div>

    <script>
       // D√©tection du type d'appareil
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// V√©rifier si c'est un appareil mobile ou desktop
document.addEventListener('DOMContentLoaded', function() {
    if (!isMobile) {
        // Masquer l'√©cran de d√©marrage normal
        document.getElementById('start-screen').style.display = 'none';
        // Afficher le message desktop
        document.getElementById('desktop-message').style.display = 'flex';
        // Masquer le conteneur de jeu
        document.getElementById('game-container').style.display = 'none';
    }
});

// √âl√©ments du DOM
const gameContainer = document.getElementById('game-container');
        const samoussa = document.getElementById('samoussa');
        const scoreElement = document.getElementById('score');
        const finalScoreElement = document.getElementById('final-score');
        const gameOverScreen = document.getElementById('game-over');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const invisibilityEffect = document.getElementById('invisibility-effect');
        const invisibilityTime = document.getElementById('invisibility-time');
        const jumpHint = document.getElementById('jump-hint');
        const boostEffect = document.getElementById('boost-effect');
        const logoGame = document.getElementById('logo-game');
        
        // Fonction pour v√©rifier si le joueur peut g√©n√©rer une r√©compense
function canGenerateReward(level) {
    try {
        // V√©rifier si nous sommes en mode test via URL
        if (window.location.href.includes('test=1')) {
            console.log("Mode test d√©tect√© via URL - Ignorant les limites de r√©compenses");
            return { canGenerate: true, isTestMode: true };
        }
        
        // Traitement sp√©cial pour le niveau 9 - v√©rification permanente
        if (level >= 9) {
            // V√©rifier si niveau 9 a d√©j√† √©t√© gagn√©
            const level9Awarded = localStorage.getItem('level9RewardAwarded');
            if (level9Awarded === 'true') {
                return {
                    canGenerate: false,
                    message: "Vous avez d√©j√† obtenu la r√©compense de niveau 9 auparavant.",
                    isPermanent: true
                };
            } else {
                // Marquer comme attribu√© de fa√ßon permanente
                localStorage.setItem('level9RewardAwarded', 'true');
                return { canGenerate: true };
            }
        }
        
        // V√©rification mensuelle normale pour les autres niveaux
        const rewardHistory = JSON.parse(localStorage.getItem('rewardHistory') || '{}');
        const now = new Date();
        const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        if (!rewardHistory[currentMonth]) {
            rewardHistory[currentMonth] = {};
        }
        
        const currentMonthHistory = rewardHistory[currentMonth];
        const rewardKey = `level${level}`;
        const rewardCount = currentMonthHistory[rewardKey] || 0;
        
        // Limites mensuelles par niveau
        const monthlyLimits = {
            5: 2,  // Niveau 5: 2 codes par mois
            6: 2,  // Niveau 6: 2 codes par mois
            7: 1,  // Niveau 7: 1 code par mois
            8: 1   // Niveau 8: 1 code par mois
        };
        
        // V√©rifier si la limite est atteinte
        if (rewardCount >= monthlyLimits[level]) {
            return {
                canGenerate: false,
                message: `Vous avez d√©j√† g√©n√©r√© le maximum de codes de niveau ${level} ce mois-ci.`,
                remainingDays: getDaysUntilNextMonth()
            };
        }
        
        // Mettre √† jour l'historique
        currentMonthHistory[rewardKey] = rewardCount + 1;
        localStorage.setItem('rewardHistory', JSON.stringify(rewardHistory));
        
        return { canGenerate: true };
    } catch (e) {
        console.error("Erreur lors de la v√©rification des limites de r√©compense:", e);
        return { canGenerate: true }; // En cas d'erreur, permettre la g√©n√©ration
    }
}

// Fonction auxiliaire pour calculer les jours restants dans le mois
function getDaysUntilNextMonth() {
    const now = new Date();
    const lastDay = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
    return lastDay - now.getDate() + 1;
}
        
        // Fonction pour g√©n√©rer un QR code de r√©compense
function generateRewardQR(score, level) {
    // D√©terminer la r√©compense selon le niveau
    let reward = "NONE";
    let rewardText = "";
    
    if (level < 5) {
        return null; // Aucune r√©compense pour niveaux inf√©rieurs
    }
    
    // V√©rifier si la g√©n√©ration est autoris√©e
    const checkResult = canGenerateReward(level);
    if (!checkResult.canGenerate) {
        // Retourner un objet sp√©cial indiquant la limite
        return {
            isLimited: true,
            message: checkResult.message,
            isPermanent: checkResult.isPermanent,
            remainingDays: checkResult.remainingDays
        };
    }
    
    if (level >= 9) {
        reward = "1_AN_WAYOWAYO";
        rewardText = "1 an de WAYOWAYO offert ! (1 repas pour 2 par mois pendant 1 an)";
    } else if (level >= 8) {
        reward = "REPAS_COMPLET_2";
        rewardText = "1 repas complet pour 2 offert ! (entr√©es + plats + desserts + boissons)";
    } else if (level >= 7) {
        reward = "4_PORTIONS";
        rewardText = "4 portions de samoussas offertes!";
    } else if (level >= 6) {
        reward = "2_PORTIONS";
        rewardText = "2 portions de samoussas offertes!";
    } else if (level >= 5) {
        reward = "1_PORTION";
        rewardText = "1 portion de samoussas offerte!";
    } else {
        return null; // Aucune r√©compense pour niveaux inf√©rieurs
    }

    // Cr√©er un identifiant unique
    const now = new Date();
    const uniqueId = now.getTime().toString(36) + Math.random().toString(36).substring(2, 5).toUpperCase();

    // Cr√©er la date d'expiration (7 jours plus tard)
    const expiryDateObj = new Date(now.getTime() + 7*24*60*60*1000);

    // Format ISO pour le QR code
    const expiryDateISO = expiryDateObj.toISOString().split('T')[0];
    const codeData = `WAYOWAYO:CODE=WY-${level}K-${uniqueId}:REWARD=${reward}:EXPIRES=${expiryDateISO}`;

    // Format fran√ßais pour l'affichage (JJ/MM/AAAA)
    const expiryDateFR = `${expiryDateObj.getDate().toString().padStart(2, '0')}/${(expiryDateObj.getMonth() + 1).toString().padStart(2, '0')}/${expiryDateObj.getFullYear()}`;
    
    // G√©n√©rer le QR code
    const qr = qrcode(0, 'L');
    qr.addData(codeData);
    qr.make();
    
    return {
        html: qr.createImgTag(5), // 5 = cell size
        code: `WY-${level}K-${uniqueId}`,
        reward: rewardText,
        expiryDate: expiryDateFR
    };
}

        // Gestion des assets et fallback
        function checkImagesLoaded() {
            const testImage = new Image();
            testImage.src = 'assets/samoussa_run1.png';
            testImage.onload = function() {
                console.log("Images charg√©es correctement");
            };
            testImage.onerror = function() {
                console.log("Impossible de charger les images, passage en mode fallback");
                document.body.classList.add('fallback-mode');
            };
        }
        
        // Fonction pour cr√©er un cocotier am√©lior√© - REMPLACER COMPL√àTEMENT
function createCocotier(x) {
    const cocotier = document.createElement('div');
    cocotier.className = 'cocotier';
    cocotier.style.left = x + '%';
    
    // Cr√©er le tronc
    const tronc = document.createElement('div');
    tronc.className = 'cocotier-tronc';
    cocotier.appendChild(tronc);
    
    // Cr√©er les feuilles
    const feuilles = document.createElement('div');
    feuilles.className = 'cocotier-feuilles';
    
    // Ajouter 8 feuilles pour un look plus fourni
    for (let i = 0; i < 8; i++) {
        const feuille = document.createElement('div');
        feuille.className = 'cocotier-feuille';
        feuilles.appendChild(feuille);
    }
    
    cocotier.appendChild(feuilles);
    
    // Ajouter trois noix de coco
    const noix = document.createElement('div');
    noix.className = 'cocotier-noix';
    cocotier.appendChild(noix);
    
    const noixGauche = document.createElement('div');
    noixGauche.className = 'cocotier-noix-gauche';
    cocotier.appendChild(noixGauche);
    
    const noixDroite = document.createElement('div');
    noixDroite.className = 'cocotier-noix-droite';
    cocotier.appendChild(noixDroite);
    
    gameContainer.appendChild(cocotier);
    
    return cocotier;
}
        
        // Fonction pour afficher un indice de strat√©gie de saut
function showJumpHint(position, strategy, duration = 1500, spacing = null) {
    
    // Jouer le son d'alerte appropri√© selon la strat√©gie
if (strategy === 'double') {
    // Son pour l'indice de double saut rapide
    AudioManager.playSound('hintDouble');
} else {
    // Son pour l'indice de saut long/maintenu
    AudioManager.playSound('hintLong');
}
    
    // Cr√©er l'√©l√©ment d'indice
    const hint = document.createElement('div');
    hint.className = 'jump-strategy-hint';
    
    // Styles de base
    hint.style.position = 'absolute';
    hint.style.zIndex = '10';
    hint.style.padding = '8px 12px';
    hint.style.borderRadius = '15px';
    hint.style.fontSize = '3.2vmin'; // L√©g√®rement plus grand
    hint.style.fontWeight = 'bold';
    hint.style.color = 'white';
    hint.style.textShadow = '0 0 4px black, 0 0 2px rgba(0,0,0,0.8)'; // Ombre plus prononc√©e
    hint.style.opacity = '0.95'; // Plus visible
    hint.style.transition = 'opacity 0.4s, transform 0.6s';
    hint.style.textAlign = 'center';
    hint.style.userSelect = 'none';
    hint.style.pointerEvents = 'none';
    hint.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)'; // Ombre port√©e pour plus de contraste
    
    // Position initiale - au-dessus de la zone des obstacles
hint.style.bottom = (initialSamoussaBottom + 90) + 'px';
// S'assurer que l'indice reste toujours visible dans la zone de jeu
let leftPos = position;
const hintWidth = 150; // Largeur approximative de l'indice
const minLeft = 10; // Position minimale √† gauche
const maxLeft = gameContainerWidth - hintWidth - 10; // Position maximale √† gauche
leftPos = Math.max(minLeft, Math.min(maxLeft, leftPos)); // Limiter entre min et max
hint.style.left = leftPos + 'px';
    
    // Diff√©rencier visuellement les types de strat√©gie
    if (strategy === 'double') {
        // Strat√©gie de double saut rapide
        hint.style.backgroundColor = 'rgba(0, 173, 239, 0.85)';
        hint.style.border = '2px solid rgba(0, 120, 209, 1)';
        hint.textContent = '2 SAUTS RAPIDES!'; // Texte plus descriptif
        
        // Ajouter une ic√¥ne
        const icon = document.createElement('div');
        icon.style.marginTop = '4px';
        icon.innerHTML = '‚Üë ‚Üë';
        icon.style.fontSize = '3.5vmin';
        hint.appendChild(icon);
    } else {
        // Strat√©gie de saut long - visibilit√© renforc√©e
        hint.style.backgroundColor = 'rgba(76, 217, 100, 0.85)';
        hint.style.border = '2px solid rgba(46, 157, 70, 1)';
        hint.style.transform = 'scale(1.1)'; // L√©g√®rement plus grand pour attirer l'attention
        hint.textContent = 'MAINTENIR APPUY√â!'; // Plus clair sur l'action √† faire
        
        // Ajouter une ic√¥ne
        const icon = document.createElement('div');
        icon.style.marginTop = '4px';
        icon.innerHTML = '‚ÜóÔ∏è LONG ‚ÜòÔ∏è';
        icon.style.fontSize = '3.5vmin';
        hint.appendChild(icon);
    }
    
    // Ajouter au conteneur de jeu
    gameContainer.appendChild(hint);
    
    // Animation d'apparition
    setTimeout(() => {
        hint.style.transform = strategy === 'single' ? 'translateY(-15px) scale(1.1)' : 'translateY(-15px)';
    }, 50);
    
    // Suppression automatique apr√®s la dur√©e sp√©cifi√©e
    setTimeout(() => {
        hint.style.opacity = '0';
        hint.style.transform = 'translateY(-30px) scale(0.9)';
        
        // Supprimer l'√©l√©ment du DOM apr√®s la fin de l'animation
        setTimeout(() => {
            if (hint.parentNode) {
                hint.remove();
            }
        }, 300);
    }, duration);
    
    return hint;
}

        // Fonction pour cr√©er une case cr√©ole am√©lior√©e
        function createCaseCreole(x) {
            const caseCreole = document.createElement('div');
            caseCreole.className = 'case-creole';
            caseCreole.style.left = x + '%';
            
            // Cr√©er le mur
            const mur = document.createElement('div');
            mur.className = 'case-mur';
            caseCreole.appendChild(mur);
            
            // Cr√©er le toit
            const toit = document.createElement('div');
            toit.className = 'case-toit';
            caseCreole.appendChild(toit);
            
            // Cr√©er la porte
            const porte = document.createElement('div');
            porte.className = 'case-porte';
            caseCreole.appendChild(porte);
            
            // Cr√©er les volets
            const voletGauche = document.createElement('div');
            voletGauche.className = 'case-volet case-volet-gauche';
            
            const voletDroite = document.createElement('div');
            voletDroite.className = 'case-volet case-volet-droite';
            
            // Ajouter les motifs Z aux volets
            const zGauche = document.createElement('div');
            zGauche.className = 'case-volet-z';
            voletGauche.appendChild(zGauche);
            
            const zDroite = document.createElement('div');
            zDroite.className = 'case-volet-z';
            voletDroite.appendChild(zDroite);
            
            caseCreole.appendChild(voletGauche);
            caseCreole.appendChild(voletDroite);
            
            gameContainer.appendChild(caseCreole);
            
            return caseCreole;
        }
        
        // Fonction pour cr√©er un nuage
        function createCloud() {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            
            // Taille al√©atoire mais l√©g√®rement plus grande
            const size = 40 + Math.random() * 50;
            cloud.style.width = size + 'px';
            cloud.style.height = size / 1.8 + 'px'; // Moins applati pour un look plus cotonneux
            
            // Position al√©atoire (r√©partie sur toute la hauteur du ciel)
            const y = Math.random() * 25;
            cloud.style.top = y + '%';
            
            // Animation
            const speed = 35 + Math.random() * 35; // Vitesse l√©g√®rement plus lente
            cloud.style.animation = `float-cloud ${speed}s linear`;
            
            // Ajouter une deuxi√®me div pour cr√©er un effet de nuage plus r√©aliste
            const cloudDetail = document.createElement('div');
            cloudDetail.style.position = 'absolute';
            cloudDetail.style.width = (size * 0.7) + 'px';
            cloudDetail.style.height = (size / 2.2) + 'px';
            cloudDetail.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            cloudDetail.style.borderRadius = '50%';
            cloudDetail.style.bottom = '40%';
            cloudDetail.style.left = '15%';
            
            cloud.appendChild(cloudDetail);
            gameContainer.appendChild(cloud);
            
            // Supprimer le nuage une fois l'animation termin√©e
            cloud.addEventListener('animationend', function() {
                cloud.remove();
            });
            
            return cloud;
        }
        // Fonction pour cr√©er un paille-en-queue
function createPailleEnQueue() {
    const paille = document.createElement('div');
    paille.className = 'paille-en-queue';
    
    // Varier l√©g√®rement la hauteur de vol
    const hauteurVol = 5 + Math.random() * 15;
    paille.style.top = hauteurVol + '%';
    
    // Appliquer un d√©lai al√©atoire √† l'animation
    const delai = Math.random() * 12;
    paille.style.animationDelay = `-${delai}s`;
    
    // Corps
    const corps = document.createElement('div');
    corps.className = 'paille-corps';
    paille.appendChild(corps);
    
    // T√™te
    const tete = document.createElement('div');
    tete.className = 'paille-tete';
    paille.appendChild(tete);
    
    // Bec
    const bec = document.createElement('div');
    bec.className = 'paille-bec';
    paille.appendChild(bec);
    
    // Ailes
    const aileHaute = document.createElement('div');
    aileHaute.className = 'paille-aile paille-aile-haute';
    paille.appendChild(aileHaute);
    
    const aileBasse = document.createElement('div');
    aileBasse.className = 'paille-aile paille-aile-basse';
    paille.appendChild(aileBasse);
    
    // Queue caract√©ristique du paille-en-queue
    const queue = document.createElement('div');
    queue.className = 'paille-queue';
    paille.appendChild(queue);
    
    gameContainer.appendChild(paille);
    
    // Supprimer l'oiseau une fois l'animation termin√©e
    paille.addEventListener('animationend', function() {
        paille.remove();
    });
    
    return paille;
}
        // Fonction pour nettoyer les pailles-en-queue existants
function clearAllPaillesEnQueue() {
    // Supprimer tous les oiseaux existants
    document.querySelectorAll('.paille-en-queue').forEach(oiseau => {
        oiseau.remove();
    });
}
        
        // Fonction pour g√©n√©rer des nuages √† intervalles r√©guliers
        function startCloudGenerator() {
             // Nettoyer les oiseaux existants au d√©marrage du g√©n√©rateur
    clearAllPaillesEnQueue();
            // G√©n√©rer quelques nuages au d√©marrage
            for (let i = 0; i < 3; i++) {
                const cloud = createCloud();
                // Position horizontale al√©atoire pour les nuages initiaux
                cloud.style.left = (Math.random() * 100) + '%';
                cloud.style.animationPlayState = 'paused'; // Nuages statiques au d√©marrage
            }
            
            // G√©n√©rer de nouveaux nuages √† intervalles al√©atoires
            return setInterval(() => {
                if (!isGameOver) {
                    createCloud();
                }
            }, 4000 + Math.random() * 3000);
        // Code √† ajouter pour les pailles-en-queue
    let pailleEnQueueInterval = setInterval(() => {
        if (!isGameOver) {
            createPailleEnQueue();
        }
    }, 15000 + Math.random() * 10000);

    // Stocker l'intervalle
    window.gameIntervals.pailleEnQueue = pailleEnQueueInterval;
    
    return cloudGeneratorInterval;
}
        
        
        // Fonction mise √† jour pour cr√©er tous les √©l√©ments d√©coratifs
        function setupDecorativeElements() {
            // Cr√©er des cocotiers de chaque c√¥t√© de l'√©cran avec position ajust√©e
            createCocotier(12);   // Cocotier √† gauche, un peu plus vers le centre
            createCocotier(82);  // Cocotier √† droite, un peu plus vers le centre
            
            // Cr√©er une case cr√©ole au milieu, pos√©e sur le sol
            createCaseCreole(50);  // Centr√© parfaitement
        }

        // V√©rifier si les images sont charg√©es
        checkImagesLoaded();
        
        // Mettre en place les √©l√©ments d√©coratifs
        setupDecorativeElements();
        
        // D√©marrer le g√©n√©rateur de nuages
        let cloudGeneratorInterval = startCloudGenerator();

        // Le reste du code JavaScript reste inchang√©
        // Variables du jeu et fonctions du jeu original
        let isJumping = false;
        let isGameOver = true;
        let isGameStarted = false;
        let isInvisible = false;
        let invisibilityTimer = 0;
        let invisibilityDuration = 5;
        let score = 0;
        let gameSpeed = 3.5;
        let maxGameSpeed = 7;
        let difficultyLevel = 1;
        let minObstacleDistance = 350;
        let lastObstaclePosition = 0;
        let gameTime = 0;
        let gameContainerWidth = gameContainer.clientWidth;
        // Variables pour la boucle de jeu unifi√©e
let lastFrameTime = 0;
let lastObstacleCheckTime = 0;
let lastCollectibleCheckTime = 0;
let lastScoreUpdateTime = 0;
let lastEffectsUpdateTime = 0;
let lastAnimationUpdateTime = 0;
        // Variable pour suivre le moment de la derni√®re g√©n√©ration d'obstacles doubles
let lastDoubleObstacleTime = 0;
// Temps de repos minimum entre deux groupes d'obstacles doubles (en millisecondes)
let doubleObstacleRestPeriod = 4000;
        
        // Variables pour le syst√®me de combo
        let comboMultiplier = 1;
        let comboCount = 0;
        let maxCombo = 1;
        let lastCollectTime = 0;
        const comboDuration = 7000; // Augment√© de 3000 √† 7000 ms (7 secondes)
        
        // R√©cup√©rer les meilleurs scores depuis le localStorage
let highScores = [];
try {
    const savedScores = localStorage.getItem('wayowayoHighScores');
    if (savedScores) {
        highScores = JSON.parse(savedScores);
    } else {
        highScores = []; // Commencer avec une liste vide au lieu de [0,0,0,0,0]
    }
} catch (e) {
    console.error("Erreur lors de la r√©cup√©ration des scores:", e);
    highScores = [];
}
        
        // Variables du saut bas√© sur la pression
        let isSpacePressed = false;
        let isTouching = false;
        let touchStartTime = 0;
        let spacePressStartTime = 0;
        let maxPressTime = 800;
        let minJumpPower = 0.3;
        let jumpPower = minJumpPower;
        let powerIndicator = null;

        // Variables de saut
        let jumpTime = 0;
        let jumpDuration = 65;
        let jumpHeight = 150;
        let initialSamoussaBottom;
        let lastJumpTime = 0;
        let jumpAnimationId = null;
        
        // Variables pour g√©rer le timing entre les frames
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;

        // Images pour les animations
        const samoussaImages = {
            run1: 'assets/samoussa_run1.png',
            run2: 'assets/samoussa_run2.png',
            crash: 'assets/samoussa_crash.png'
        };
        
        // Types d'obstacles et de collectibles
        const obstacleTypes = ['couteau', 'marmite', 'main'];
        const collectibleTypes = ['piment', 'epice', 'biere'];
        let currentFrame = 0;
        
        // Tableaux pour stocker les √©l√©ments du jeu
        let obstacles = [];
        let collectibles = [];
        
        // Planification des √©l√©ments
        let nextObstacleTime = 3000;
        let nextCollectibleTime = 2000;
        
        // Adaptation mobile vs desktop
        if (isMobile) {
            // Afficher l'indice de saut pour mobile
            jumpHint.style.display = 'block';
            // Param√®tres sp√©cifiques au mobile
            maxPressTime = 500; // Plus court sur mobile
            
            // Ajuster la vitesse du jeu l√©g√®rement pour mobile
            gameSpeed = 3.2; // Un peu plus lent sur mobile
        }

        // Cr√©er l'indicateur de puissance
        function createPowerIndicator() {
            powerIndicator = document.createElement('div');
            powerIndicator.className = 'power-indicator';
            powerIndicator.style.display = 'none';
            
            const powerBar = document.createElement('div');
            powerBar.className = 'power-bar';
            powerIndicator.appendChild(powerBar);
            
            gameContainer.appendChild(powerIndicator);
        }

        // S'assurer que l'√©cran de d√©marrage est visible au d√©but
        startScreen.style.display = 'flex';
        samoussa.style.display = 'block';
        
        // Cr√©er l'indicateur de puissance
        createPowerIndicator();
        
     function optimizeGameForFullscreen() {
    // Dimensions de base
    document.documentElement.style.height = '100%';
    document.body.style.height = '100%';
    
    // R√©cup√©rer les dimensions r√©elles de l'√©cran
    const windowHeight = window.innerHeight;
    const windowWidth = window.innerWidth;
    
    // Dimensions du conteneur
    gameContainer.style.width = '100%';
    gameContainer.style.height = '100vh';
    gameContainer.style.maxWidth = '800px';
    gameContainer.style.maxHeight = 'none';
    
    // Augmenter significativement la hauteur du sol (30% au lieu de 20%)
    const groundHeight = windowHeight * 0.30;
    initialSamoussaBottom = groundHeight;
    
    // Ajuster le sol
    const ground = document.getElementById('ground');
    ground.style.height = groundHeight + 'px';
    
    // Positionner le samoussa
    samoussa.style.bottom = initialSamoussaBottom + 'px';
    
    // Recalculer tous les obstacles
    obstacles.forEach(obstacle => {
        obstacle.element.style.bottom = initialSamoussaBottom + 'px';
    });
    
    // Repositionner tous les collectibles
    collectibles.forEach(collectible => {
        // Si le collectible √©tait √† une hauteur relative au sol
        const currentBottom = parseFloat(collectible.element.style.bottom);
        const bottomOffset = currentBottom - (windowHeight * 0.15);
        collectible.element.style.bottom = (groundHeight + bottomOffset) + 'px';
    });
    
    // Repositionner les √©l√©ments d√©coratifs
    document.querySelectorAll('.cocotier, .case-creole').forEach(element => {
        element.style.bottom = groundHeight + 'px';
    });
    
    // Mettre √† jour la montagne
    const montagnes = document.querySelector('.montagne');
    if (montagnes) {
        montagnes.style.bottom = groundHeight + 'px';
    }
    
    
    // Mettre √† jour la largeur pour les calculs
    gameContainerWidth = gameContainer.clientWidth;
    
    // Ajuster la hauteur de saut proportionnellement
    jumpHeight = windowHeight * 0.28;
}
        
       function resizeGame() {
    // Appeler la fonction d'optimisation plein √©cran
    optimizeGameForFullscreen();
    
    // Mettre √† jour la largeur du conteneur pour les calculs internes
    gameContainerWidth = gameContainer.clientWidth;
    
    // Conserver la dynamique de jeu originale bas√©e sur la hauteur
    jumpHeight = gameContainer.clientHeight * 0.3;
}
        
        // Appeler resize au chargement et au redimensionnement
        window.addEventListener('load', resizeGame);
        window.addEventListener('resize', resizeGame);

        // √âv√©nements pour clavier
        document.addEventListener('keydown', function(event) {
            // D√©marrer le jeu avec la touche Entr√©e
            if ((event.code === 'Enter' || event.key === 'Enter') && !isGameStarted) {
                startGame();
                return;
            }
            
            // Commencer √† charger le saut quand on appuie sur espace
            if ((event.code === 'Space' || event.key === ' ') && !isJumping && !isGameOver && isGameStarted && !isSpacePressed) {
                isSpacePressed = true;
                spacePressStartTime = Date.now();
                jumpPower = minJumpPower;
                
                // Commencer l'animation de charge
                startJumpCharge();
            }
        });
        
        document.addEventListener('keyup', function(event) {
            // Sauter quand on rel√¢che la barre d'espace
            if ((event.code === 'Space' || event.key === ' ') && isSpacePressed && !isGameOver && isGameStarted) {
                const pressDuration = Date.now() - spacePressStartTime;
                const normalizedDuration = Math.min(pressDuration / maxPressTime, 1.0);
                
                // Calculer la puissance entre min et max
                jumpPower = minJumpPower + (1 - minJumpPower) * normalizedDuration;
                
                // Cacher l'indicateur de puissance
                if (powerIndicator) {
                    powerIndicator.style.display = 'none';
                }
                
                isSpacePressed = false;
                jump();
            }
        });
        
        // √âv√©nements tactiles pour mobile
        gameContainer.addEventListener('touchstart', function(event) {
            event.preventDefault(); // Emp√™cher le zoom/scroll
            
            // Si le jeu est d√©j√† d√©marr√©, d√©marrer le chargement du saut
            if (isGameStarted && !isGameOver && !isJumping && !isTouching) {
                isTouching = true;
                touchStartTime = Date.now();
                jumpPower = minJumpPower;
                
                // Commencer l'animation de charge
                startJumpCharge();
                
                // Cacher l'indice apr√®s le premier saut
                jumpHint.style.display = 'none';
            }
        }, { passive: false });

        gameContainer.addEventListener('touchend', function(event) {
            // Sauter quand on rel√¢che
            if (isTouching && !isGameOver && isGameStarted) {
                const pressDuration = Date.now() - touchStartTime;
                const normalizedDuration = Math.min(pressDuration / maxPressTime, 1.0);
                
                // Calculer la puissance entre min et max
                jumpPower = minJumpPower + (1 - minJumpPower) * normalizedDuration;
                
                // Cacher l'indicateur de puissance
                if (powerIndicator) {
                    powerIndicator.style.display = 'none';
                }
                
                isTouching = false;
                jump();
            }
        });
        
        // Emp√™cher le d√©filement de la page sur mobile
        document.addEventListener('touchmove', function(event) {
            if (isGameStarted && !isGameOver) {
                event.preventDefault();
            }
        }, { passive: false });
        
        // Clic dans le conteneur du jeu
        gameContainer.addEventListener('click', function(event) {
            // Si le jeu est d√©j√† d√©marr√©, permettre de sauter en cliquant
            if (isGameStarted && !isGameOver && !isElementClicked(event.target, [startButton, restartButton])) {
                // Pour les clics simples, saut √† 80% de puissance
                jumpPower = 0.8;
                jump();
                
                // Cacher l'indice apr√®s le premier saut
                jumpHint.style.display = 'none';
            }
        });

        // D√©marrer le jeu avec un clic sur le bouton Jouer
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', restartGame);
        
        // Ajouter des √©v√©nements tactiles sp√©cifiques pour les boutons de l'√©cran de game over
        restartButton.addEventListener('touchstart', function(event) {
            event.preventDefault();
            restartGame();
        });
        
        // Configuration des boutons de partage
        function setupShareButtons() {
            // Bouton de partage sur X (Twitter)
            const shareXBtn = document.getElementById('share-x-btn');
            shareXBtn.addEventListener('click', function() {
                shareScore('x');
            });
            shareXBtn.addEventListener('touchstart', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(0.95)';
            });
            shareXBtn.addEventListener('touchend', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(1)';
                shareScore('x');
            });
            
            // Bouton de partage sur WhatsApp
            const shareWhatsappBtn = document.getElementById('share-whatsapp-btn');
            shareWhatsappBtn.addEventListener('click', function() {
                shareScore('whatsapp');
            });
            shareWhatsappBtn.addEventListener('touchstart', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(0.95)';
            });
            shareWhatsappBtn.addEventListener('touchend', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(1)';
                shareScore('whatsapp');
            });
            
            // Bouton de partage par SMS
            const shareSmsBtn = document.getElementById('share-sms-btn');
            shareSmsBtn.addEventListener('click', function() {
                shareScore('sms');
            });
            shareSmsBtn.addEventListener('touchstart', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(0.95)';
            });
            shareSmsBtn.addEventListener('touchend', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(1)';
                shareScore('sms');
            });
        }
        
        // Initialiser les boutons de partage au chargement
        document.addEventListener('DOMContentLoaded', setupShareButtons);

        // V√©rifier si un √©l√©ment cliqu√© est dans une liste d'√©l√©ments
        function isElementClicked(element, elementList) {
            return elementList.some(el => el === element || el.contains(element));
        }

        // Animation de chargement du saut avec indicateur visuel
        function startJumpCharge() {
            if ((!isSpacePressed && !isTouching) || isJumping || isGameOver) return;
            
            // Animer le samoussa pour indiquer le chargement
            const currentTime = Date.now();
            const pressStart = isSpacePressed ? spacePressStartTime : touchStartTime;
            const progress = Math.min((currentTime - pressStart) / maxPressTime, 1.0);
            
            // Actualiser la puissance du saut
            jumpPower = minJumpPower + ((1 - minJumpPower) * progress);
            
            // Mettre √† jour l'indicateur visuel de puissance
            if (powerIndicator) {
                powerIndicator.style.display = 'block';
                const powerBar = powerIndicator.querySelector('.power-bar');
                if (powerBar) {
                    powerBar.style.width = `${progress * 100}%`;
                }
            }
            
            // Animation visuelle de chargement - compression puis extension
            if (progress < 0.5) {
                // Phase de compression
                const scale = 1 - (progress * 0.25);
                samoussa.style.transform = `scale(${scale}, ${1 + progress * 0.25})`;
            } else {
                // Phase de pr√©paration avec effet de pulsation
                const bounce = Math.sin((progress - 0.5) * 6 * Math.PI) * 0.05;
                samoussa.style.transform = `scale(${0.85 + bounce}, ${1.15 - bounce})`;
            }
            
            // Continuer l'animation tant que la touche/√©cran est press√©e
            if (isSpacePressed || isTouching) {
                requestAnimationFrame(startJumpCharge);
            } else {
                // Cacher l'indicateur quand on rel√¢che
                if (powerIndicator) {
                    powerIndicator.style.display = 'none';
                }
            }
        }

        function jump() {
    if (isJumping || isGameOver) return;
    
    // R√©initialiser en cas de probl√®me (une seule fois)
    if (jumpAnimationId) {
        cancelAnimationFrame(jumpAnimationId);
        jumpAnimationId = null;
    }
    
    // Initialiser les variables de saut (une seule fois)
    isJumping = true;
    jumpTime = 0;
    lastJumpTime = 0;
    
    // Position initiale du samoussa
    const initialBottom = parseInt(window.getComputedStyle(samoussa).getPropertyValue('bottom'));
    
    // Jouer le son de saut √† ce moment pr√©cis
    AudioManager.playSound('jump');
    
    // √âliminer toute transition pr√©c√©dente
    samoussa.style.transition = "";
    
    // Appliquer la puissance du saut aux param√®tres
    const actualJumpHeight = jumpHeight * jumpPower;
            
            // Syst√®me de rafra√Æchissement adaptatif
            let previousProgress = 0;
            
            function updateJump(timestamp) {
                if (isGameOver) {
                    isJumping = false;
                    jumpAnimationId = null;
                    return;
                }
                
                if (!lastJumpTime) lastJumpTime = timestamp;
                const deltaTime = timestamp - lastJumpTime;
                
                // Contr√¥le plus fin pour animations rapides
                if (deltaTime < 8) {
                    jumpAnimationId = requestAnimationFrame(updateJump);
                    return;
                }
                
                jumpTime += deltaTime / 16;
                lastJumpTime = timestamp;
                
                // Animation visuelle de d√©placement
                const jumpProgress = Math.min(jumpTime / jumpDuration, 1.0);
                
                // Hauteur de saut parabolique
                const verticalPosition = Math.sin(jumpProgress * Math.PI) * actualJumpHeight + initialBottom;
                
                // Position horizontale fixe
                samoussa.style.bottom = verticalPosition + 'px';
                
                // Illusion de mouvement horizontal par transformation CSS
                let visualOffset = 0;
                if (jumpProgress < 0.5) {
                    // Mouvement visuel vers l'avant jusqu'√† 50% du saut
                    visualOffset = jumpProgress * 50;
                } else {
                    // Retour progressif √† la position neutre
                    visualOffset = (1 - jumpProgress) * 50;
                }
                
                // Rotation combin√©e avec translation pour effet de mouvement
                let rotationAngle = 0;
                if (jumpProgress < 0.3) {
                    rotationAngle = 15;
                } else if (jumpProgress < 0.7) {
                    rotationAngle = 0;
                } else {
                    rotationAngle = -10;
                }
                
                // Appliquer la transformation combin√©e
                samoussa.style.transform = `rotate(${rotationAngle}deg) translateX(${visualOffset}px)`;
                
                // Fin anticip√©e du saut pour permettre un encha√Ænement plus rapide
                if (previousProgress > 0.8 && jumpProgress >= 0.98) {
                    finishJump();
                    return;
                }
                
                previousProgress = jumpProgress;
                
                // Continuer le saut jusqu'√† la fin
                if (jumpProgress < 1.0) {
                    jumpAnimationId = requestAnimationFrame(updateJump);
                } else {
                    finishJump();
                }
            }
            
            // Fonction s√©par√©e pour terminer le saut proprement
            function finishJump() {
                isJumping = false;
                jumpAnimationId = null;
                
                // Retour √† la position de repos sans effet visuel
                samoussa.style.bottom = initialSamoussaBottom + 'px';
                samoussa.style.transform = 'rotate(0deg)';
            }
            
            jumpAnimationId = requestAnimationFrame(updateJump);
        }

        // Fonction pour d√©marrer le jeu
        function startGame() {
    // V√©rifier √† nouveau si c'est un appareil mobile
    if (!isMobile) {
        console.log("Tentative de d√©marrage sur desktop bloqu√©e");
        document.getElementById('desktop-message').style.display = 'flex';
        return; // Arr√™ter l'ex√©cution de la fonction
    }
            
// Assurez-vous que le contexte audio est dans un √©tat correct avant de jouer la musique
    if (AudioManager && AudioManager.context) {
        // S'assurer que le contexte est repris
        if (AudioManager.context.state !== "running") {
            AudioManager.context.resume().then(() => {
                // Ajouter un petit d√©lai avant de jouer la musique
                setTimeout(() => {
                    AudioManager.playMusic('sounds/background.mp3');
                }, 50);
            });
        } else {
            // Ajouter un petit d√©lai avant de jouer la musique
            setTimeout(() => {
                AudioManager.playMusic('sounds/background.mp3');
            }, 50);
        }
    } else {
        // Fallback si le gestionnaire audio n'est pas disponible
        setTimeout(() => {
            if (AudioManager) AudioManager.playMusic('sounds/background.mp3');
        }, 100);
    }
            
             // AJOUTER CETTE LIGNE - Nettoyer les oiseaux existants
    clearAllPaillesEnQueue();
    
            const existingMiniButton = document.getElementById('mini-replay-button');
if (existingMiniButton) {
    existingMiniButton.remove();
}
            console.log("D√©marrage du jeu");
            startScreen.style.display = 'none';
            isGameOver = false;
            isGameStarted = true;
            isInvisible = false;
            invisibilityTimer = 0;
            score = 0;
            gameTime = 0;
            
            // R√©initialiser les variables de difficult√©
            gameSpeed = isMobile ? 2.7 : 3; // Valeur initiale de gameSpeed
            difficultyLevel = 1; // Valeur initiale de difficultyLevel
            minObstacleDistance = 350; // Valeur initiale de la distance entre obstacles
            
            // R√©initialiser le syst√®me de combo
            comboMultiplier = 1;
            comboCount = 0;
            maxCombo = 1;
            document.getElementById('combo-container').style.display = 'none';
            document.getElementById('combo-count').textContent = 'x1';
            
            // Mettre √† jour l'affichage
            scoreElement.textContent = score;
            lastObstaclePosition = 0;
            nextObstacleTime = 3000;
            nextCollectibleTime = 2000;
            
            // Masquer le tableau des scores pendant le jeu
            document.getElementById('highscores').style.display = 'none';
            
            // Cr√©er un paille-en-queue initial apr√®s le d√©marrage
setTimeout(() => {
    createPailleEnQueue();
}, 3000); // Attendre 3 secondes pour qu'il apparaisse apr√®s le d√©but du jeu
            
            // Mettre √† jour l'affichage du saut
        if (isMobile) {
            jumpHint.innerHTML = 'Tapez pour sauter !<br><span style="color: #FFD700; font-size: 0.9em; margin-top: 5px; display: inline-block;">Appuyez longtemps pour sauter plus haut</span>';
            jumpHint.style.display = 'block';
            // Le cacher apr√®s un d√©lai plus long
            setTimeout(() => {
                jumpHint.style.display = 'none';
            }, 5000);
        }
            
            // R√©initialiser la position du samoussa
            samoussa.style.bottom = initialSamoussaBottom + 'px';
            samoussa.style.transform = 'rotate(0deg)';
            samoussa.style.backgroundImage = `url(${samoussaImages.run1})`;
            samoussa.classList.remove('invisible');
            invisibilityEffect.style.display = 'none';
            
            // Activer l'animation des nuages
            document.querySelectorAll('.cloud').forEach(cloud => {
                cloud.style.animationPlayState = 'running';
            });
            
            // Lancer ou relancer le g√©n√©rateur de nuages
            if (!cloudGeneratorInterval) {
                cloudGeneratorInterval = startCloudGenerator();
            }
            
            // Supprimer tous les obstacles et collectibles existants
            clearElements();
            
            // Intervalles pour le jeu
const gameInterval = setInterval(() => {
    // Mettre √† jour le temps de jeu
    gameTime += 100;
    
    // G√©n√©rer les obstacles
    if (gameTime >= nextObstacleTime) {
        // V√©rifier s'il est trop t√¥t pour g√©n√©rer de nouveaux obstacles doubles
        const tooSoonForDoubleObstacle = (gameTime - lastDoubleObstacleTime < doubleObstacleRestPeriod);
        
        // Si des obstacles doubles ont √©t√© g√©n√©r√©s r√©cemment et niveau <= 6, forcer un obstacle simple
        if (difficultyLevel <= 6 && tooSoonForDoubleObstacle) {
            // Sauvegarder la valeur originale de createDouble
            const originalCreateDouble = Math.random() < 0.25 && difficultyLevel >= 4;
            
            // Temporairement forcer les obstacles simples
            const createDoubleBackup = window.createDoubleOverride;
            window.createDoubleOverride = true;
            
            // Appel √† createObstacle avec override
            createObstacle();
            
            // Restaurer l'√©tat
            window.createDoubleOverride = createDoubleBackup;
        } else {
            // Comportement normal
            createObstacle();
        }
        
        // Prochain obstacle avec d√©lai variable bas√© sur la difficult√©
        let minDelay = Math.max(1000, 1800 - ((difficultyLevel - 1) * 100));
        let maxAdditionalDelay = Math.max(500, 1500 - ((difficultyLevel - 1) * 150));
        
        // Si nous venons de g√©n√©rer un obstacle double, augmenter le d√©lai pour la prochaine g√©n√©ration
        if (gameTime - lastDoubleObstacleTime < 1000) {
            // Ajouter un d√©lai suppl√©mentaire apr√®s des obstacles doubles
            minDelay += 800;
            maxAdditionalDelay += 500;
        }
        
        nextObstacleTime = gameTime + minDelay + Math.random() * maxAdditionalDelay;
    }
    
    // G√©n√©rer les collectibles
    if (gameTime >= nextCollectibleTime) {
        createSafeCollectible();
        // Prochain collectible avec d√©lai variable
        const minDelay = 3000;
        const maxAdditionalDelay = 2000;
        nextCollectibleTime = gameTime + minDelay + Math.random() * maxAdditionalDelay;
    }
    
    // V√©rifier si le combo doit √™tre r√©initialis√© (temps √©coul√© depuis la derni√®re collecte)
    if (comboCount > 0 && Date.now() - lastCollectTime > comboDuration) {
        resetCombo();
    }
}, 100);

// Intervalles pour l'animation et le score
const scoreInterval = setInterval(updateScore, 100);
const animationInterval = setInterval(animateSamoussa, 200);
const effectsInterval = setInterval(updateEffects, 1000);

// Stocker les intervalles pour pouvoir les arr√™ter plus tard
window.gameIntervals = {
    game: gameInterval,
    score: scoreInterval,
    animation: animationInterval,
    effects: effectsInterval
};

// R√©initialiser le timer pour l'animation
lastFrameTime = 0;

// D√©marrer l'animation du jeu
requestAnimationFrame(updateGame);
        }

        // Fonction pour red√©marrer le jeu
        function restartGame() {
            gameOverScreen.style.display = 'none';
            
            // R√©initialiser les variables
            isJumping = false;
            isSpacePressed = false;
            isTouching = false;
            jumpTime = 0;
            
            // Red√©marrer le jeu apr√®s une courte pause
            setTimeout(() => {
                startGame();
            }, 100);
        }

        // Nettoyer les √©l√©ments existants
        function clearElements() {
            obstacles.forEach(obstacle => {
                if (obstacle.element && obstacle.element.parentNode) {
                    obstacle.element.remove();
                }
            });
            collectibles.forEach(collectible => {
                if (collectible.element && collectible.element.parentNode) {
                    collectible.element.remove();
                }
            });
            obstacles = [];
            collectibles = [];
        }

        // Animer le samoussa
        function animateSamoussa() {
            if (isGameOver || isJumping) return;
            
            currentFrame = (currentFrame + 1) % 2;
            
            // Alterner entre les deux images de course
            if (!document.body.classList.contains('fallback-mode')) {
                if (currentFrame === 0) {
                    samoussa.style.backgroundImage = `url(${samoussaImages.run1})`;
                } else {
                    samoussa.style.backgroundImage = `url(${samoussaImages.run2})`;
                }
            }
        }
function calculateJumpableDistance() {
    // Distance couverte pendant la dur√©e d'un saut √† vitesse actuelle
    const jumpTimeFrames = jumpDuration;
    const distancePerFrame = gameSpeed;
    
    // Distance max franchissable avec un saut √† pleine puissance
    const maxJumpDistance = jumpTimeFrames * distancePerFrame;
    
    // Temps n√©cessaire pour retomber et pouvoir ressauter (frames)
    // Adaptation intelligente selon la vitesse du jeu - plus de marge quand c'est rapide
    const baseRecoveryFrames = 30;
    const speedFactor = Math.min(1.5, Math.max(1, gameSpeed / 4)); // 1 √† 1.5x selon la vitesse
    const recoveryFrames = Math.ceil(baseRecoveryFrames * speedFactor);
    
    // Distance minimale n√©cessaire entre deux obstacles pour permettre deux sauts
    const minDoubleJumpDistance = maxJumpDistance + (recoveryFrames * distancePerFrame);
    
    // Distance maximale franchissable en un seul saut avec une marge de s√©curit√©
    // R√©duite pour √™tre s√ªr que c'est faisable
    const safeMaxSingleJump = maxJumpDistance * 0.8;
    
    console.log(`[DEBUG] gameSpeed: ${gameSpeed}, recoveryFrames: ${recoveryFrames}`);
    console.log(`[DEBUG] maxJump: ${maxJumpDistance}, doubleJumpDist: ${minDoubleJumpDistance}`);
    
    return {
        maxSingleJump: safeMaxSingleJump,
        minDoubleJumpDistance: minDoubleJumpDistance,
        // Distance id√©ale pour un saut double (avec marge de confort)
        idealDoubleJumpDistance: minDoubleJumpDistance * 1.3, // Augment√© de 1.2 √† 1.3
        // Distance id√©ale pour un saut simple (ni trop proche ni trop loin)
        idealSingleJumpDistance: safeMaxSingleJump * 0.7
    };
}
// Fonction pour cr√©er un obstacle
function createObstacle() {
    if (isGameOver) return;
    
    // V√©rifier la distance avec le dernier obstacle
    const rightmostObstacle = obstacles.reduce((maxPos, obstacle) => 
        Math.max(maxPos, obstacle.position), 0);
    
    const adjustedDistance = minObstacleDistance * (gameContainerWidth / 800);
    
    if (rightmostObstacle > gameContainerWidth - adjustedDistance) {
        return;
    }
    
    // √Ä des niveaux plus √©lev√©s, possibilit√© d'obstacles doubles
    let createDouble = false;
    if (difficultyLevel >= 4 && Math.random() < 0.25) {
        createDouble = true;
    }
    
    // Cr√©er le premier obstacle
    const obstacle = document.createElement('div');
    obstacle.classList.add('obstacle');
    
    // Type d'obstacle al√©atoire
    const obstacleType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
    obstacle.classList.add(obstacleType);
    
    // Position initiale √† droite de l'√©cran
    obstacle.style.left = gameContainerWidth + 'px';
    obstacle.style.bottom = initialSamoussaBottom + 'px';
    gameContainer.appendChild(obstacle);
    
    obstacles.push({
        element: obstacle,
        position: gameContainerWidth,
        type: obstacleType
    });
    
    lastObstaclePosition = gameContainerWidth;
    
    // Cr√©er un deuxi√®me obstacle si n√©cessaire
    if (createDouble && difficultyLevel >= 4) {
        // M√©moriser que nous venons de cr√©er un obstacle double
        lastDoubleObstacleTime = gameTime;
        
        setTimeout(() => {
            if (isGameOver) return;
            
            const obstacle2 = document.createElement('div');
            obstacle2.classList.add('obstacle');
            
            // Type diff√©rent pour le second obstacle
            let obstacleType2;
            do {
                obstacleType2 = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            } while (obstacleType2 === obstacleType && obstacleTypes.length > 1);
            
            obstacle2.classList.add(obstacleType2);
            
                // Facteur d'√©chelle bas√© sur la taille de l'√©cran
            const spacingFactor = gameContainerWidth / 800;
            
            // Calculer les distances de saut possibles avec la vitesse actuelle
            const jumpability = calculateJumpableDistance();
            
            // Variable pour stocker la strat√©gie et l'espacement
            let jumpStrategy;
            let spacing;
            
            // Pour forcer l'apparition du saut long parfois, ind√©pendamment du niveau
            const forceLongJump = Math.random() < 0.3; // 30% de chance de forcer un saut long
            
            // D√©terminer la strat√©gie selon le niveau et le hasard
            if ((difficultyLevel <= 5 && !forceLongJump) || (difficultyLevel <= 3)) {
                // Niveaux 4-5: G√âN√âRALEMENT configurer pour double saut avec une grande marge de s√©curit√©
                jumpStrategy = 'double';
                
                // Traitement sp√©cial pour le niveau 5 qui est un peu plus difficile
if (difficultyLevel === 5) {
   
    spacing = jumpability.idealDoubleJumpDistance * 1.9 * spacingFactor;
} else {
    // Espacement tr√®s g√©n√©reux pour les autres niveaux
    spacing = jumpability.idealDoubleJumpDistance * 1.45 * spacingFactor;
}
            }
            else if (difficultyLevel <= 7) {
                // Niveaux 6-7: M√©lange plus √©quilibr√©
                if (Math.random() < 0.4 || forceLongJump) {
                    // 40% de chance d'avoir un saut simple (ou forc√©)
                    jumpStrategy = 'single';
                    // Distance NETTEMENT plus courte pour √™tre franchie en un seul saut
                    spacing = jumpability.idealSingleJumpDistance * 0.8 * spacingFactor;
                } else {
                    // 60% de chance d'avoir un double saut
                    jumpStrategy = 'double';
                    // Espacement tr√®s confortable aux niveaux interm√©diaires
                    spacing = jumpability.idealDoubleJumpDistance * 2 * spacingFactor;
                }
            }
            else {
                // Niveaux 8+: Pr√©f√©rence pour les sauts simples
                if (Math.random() < 0.6 || forceLongJump) {
                    // 60% de chance d'avoir un saut simple (ou forc√©)
                    jumpStrategy = 'single';
                    // Distance courte mais franchissable en un saut
                    spacing = jumpability.idealSingleJumpDistance * spacingFactor;
                } else {
                    // 40% de chance d'avoir un double saut
                    jumpStrategy = 'double';
                    // Espacement difficile mais faisable avec un timing pr√©cis
                    spacing = jumpability.idealDoubleJumpDistance * 1.95 * spacingFactor;
                }
            }
            
            // Ajustement final pour √©viter des espacements trop extr√™mes
            if (jumpStrategy === 'single') {
                // Pour la strat√©gie de saut unique, s'assurer que c'est VRAIMENT court
                spacing = Math.min(spacing, jumpability.maxSingleJump * 0.7 * spacingFactor);
                // Minimum absolu pour √©viter des obstacles qui se chevauchent
                spacing = Math.max(spacing, 150 * spacingFactor);
            } else {
                // Pour la strat√©gie de double saut, s'assurer qu'il y a assez d'espace
                spacing = Math.max(spacing, jumpability.minDoubleJumpDistance * 1.1 * spacingFactor);
                // Maximum absolu pour la sant√© mentale
                spacing = Math.min(spacing, 550 * spacingFactor);
            }
            
            // Afficher l'indice visuel de strat√©gie BEAUCOUP plus t√¥t
            if (difficultyLevel >= 4) {
                // Position qui pr√©c√®de les obstacles - diff√©renci√©e selon le type de saut
let hintPosition;
if (jumpStrategy === 'single') {
    // Afficher beaucoup plus t√¥t l'indice pour le saut long
    hintPosition = gameContainerWidth * 0.95;  // Presque √† l'extr√™me droite de l'√©cran
} else {
    // Position standard pour le double saut
    hintPosition = gameContainerWidth * 0.85;
}

// Dur√©e adapt√©e selon la strat√©gie - plus longue pour le saut long
let hintDuration;
if (jumpStrategy === 'single') {
    // Dur√©e plus longue pour le saut long qui n√©cessite plus de pr√©paration
    hintDuration = Math.max(2200, 2800 - ((difficultyLevel - 4) * 100));  // Augment√©e
} else {
    // Dur√©e standard pour le double saut
    hintDuration = Math.max(1200, 2000 - ((difficultyLevel - 4) * 100));
}
                
                // Toujours montrer les indices
                showJumpHint(hintPosition, jumpStrategy, hintDuration, spacing);
            }
            obstacle2.style.bottom = initialSamoussaBottom + 'px';
            gameContainer.appendChild(obstacle2);
            
            obstacles.push({
                element: obstacle2,
                position: gameContainerWidth + spacing,
                type: obstacleType2
            });
            
            lastObstaclePosition = gameContainerWidth + spacing;
        }, 100);
    }
}

        // Fonction pour cr√©er un collectible accessible et sans collision avec les obstacles
        function createSafeCollectible() {
            if (isGameOver) return;
            
            const collectible = document.createElement('div');
            collectible.classList.add('collectible');
            
            // Type de collectible al√©atoire
            const collectibleType = collectibleTypes[Math.floor(Math.random() * collectibleTypes.length)];
            collectible.classList.add(collectibleType);
            
            // Position toujours √† droite de l'√©cran
            let positionX = gameContainerWidth;
            collectible.style.left = positionX + 'px';
            
            // R√©cup√©rer tous les obstacles existants pour v√©rifier les collisions
            const allObstacles = obstacles.map(o => ({
                x: o.position,
                y: parseInt(o.element.style.bottom) || initialSamoussaBottom,
                width: parseInt(window.getComputedStyle(o.element).width),
                height: parseInt(window.getComputedStyle(o.element).height)
            }));
            
            // Tentatives de placement sans collision
            let attempts = 0;
            let validPosition = false;
            let positionY = 0;
            
            while (!validPosition && attempts < 20) {
                attempts++;
                
                // D√©terminer une position verticale de base
                const gameHeight = gameContainer.clientHeight;
                if (Math.random() < 0.7) {
                    // 70% du temps en hauteur
                    positionY = Math.random() * (gameHeight * 0.3) + (initialSamoussaBottom + 30);
                } else {
                    // 30% du temps pr√®s du sol
                    positionY = Math.random() * 30 + (initialSamoussaBottom + 10);
                }
                
                // V√©rifier la distance avec tous les obstacles
                let tooClose = false;
                
                for (const obstacle of allObstacles) {
                    // Distance horizontale
                    const horizontalDistance = Math.abs(positionX - obstacle.x);
                    
                    // Distance verticale
                    const collectibleHeight = (collectibleType === 'biere') ? 60 : 50;
                    const verticalOverlap = (positionY < obstacle.y + obstacle.height) && 
                                           (positionY + collectibleHeight > obstacle.y);
                    
                    // Si trop proche horizontalement et en chevauchement vertical
                    if (horizontalDistance < 100 && verticalOverlap) {
                        tooClose = true;
                        break;
                    }
                }
                
                // Si position valide (pas trop proche d'obstacles)
                if (!tooClose) {
                    validPosition = true;
                } else {
                    // Ajuster la position X pour √©viter les obstacles
                    positionX += 50 + Math.random() * 50;
                }
            }
            
            // Si apr√®s 20 tentatives toujours pas de position valide, placer loin
            if (!validPosition) {
                positionX = gameContainerWidth + 200 + Math.random() * 200;
                positionY = Math.random() * (gameContainer.clientHeight * 0.3) + (initialSamoussaBottom + 30);
            }
            
            // Appliquer les positions
            collectible.style.left = positionX + 'px';
            collectible.style.bottom = positionY + 'px';
            
            gameContainer.appendChild(collectible);
            
            collectibles.push({
                element: collectible,
                position: positionX,
                bottom: positionY,
                type: collectibleType
            });
        }

// Fonction pour v√©rifier les collisions avec des hitboxes pr√©cises
        function checkCollision(element1, element2) {
            // Version am√©lior√©e qui utilise les pseudo√©l√©ments ::after comme hitbox
            const rect1 = element1.getBoundingClientRect();
            const rect2 = element2.getBoundingClientRect();
            
            // Taille relative de la hitbox par rapport √† l'√©l√©ment parent
            // Ces valeurs correspondent aux pourcentages dans le CSS
            const hitbox1 = {
                width: rect1.width * 0.7, 
                height: rect1.height * 0.7,
                left: rect1.left + rect1.width * 0.15,
                top: rect1.top + rect1.height * 0.15
            };
            
            // D√©terminer la taille de hitbox en fonction du type d'√©l√©ment
            let hitbox2;
            if (element2.classList.contains('couteau')) {
                hitbox2 = {
                    width: rect2.width * 0.6,
                    height: rect2.height * 0.7,
                    left: rect2.left + rect2.width * 0.2,
                    top: rect2.top + rect2.height * 0.15
                };
            } else if (element2.classList.contains('marmite')) {
                hitbox2 = {
                    width: rect2.width * 0.7,
                    height: rect2.height * 0.8,
                    left: rect2.left + rect2.width * 0.15,
                    top: rect2.top + rect2.height * 0.15
                };
            } else if (element2.classList.contains('main')) {
                hitbox2 = {
                    width: rect2.width * 0.7,
                    height: rect2.height * 0.9,
                    left: rect2.left + rect2.width * 0.15,
                    top: rect2.top + rect2.height * 0.05
                };
            } else if (element2.classList.contains('collectible')) {
                hitbox2 = {
                    width: rect2.width * 0.7,
                    height: rect2.height * 0.7,
                    left: rect2.left + rect2.width * 0.15,
                    top: rect2.top + rect2.height * 0.15
                };
            } else {
                // Hitbox par d√©faut
                hitbox2 = {
                    width: rect2.width,
                    height: rect2.height,
                    left: rect2.left,
                    top: rect2.top
                };
            }
            
            // V√©rifier si les hitboxes se chevauchent
            return !(
                hitbox1.left + hitbox1.width < hitbox2.left ||
                hitbox1.left > hitbox2.left + hitbox2.width ||
                hitbox1.top + hitbox1.height < hitbox2.top ||
                hitbox1.top > hitbox2.top + hitbox2.height
            );
        }

        // Mettre √† jour le score et la difficult√©
        function updateScore() {
            if (isGameOver) return;
            
            score += 1;
            scoreElement.textContent = score;
            
            // Paliers de difficult√©
            const difficultyThresholds = [
                { score: 300, speed: isMobile ? 3.2 : 3.5, distance: 330, level: 2 },
                { score: 600, speed: isMobile ? 3.7 : 4.0, distance: 300, level: 3 },
                { score: 1000, speed: isMobile ? 4.2 : 4.5, distance: 280, level: 4 },
                { score: 1500, speed: isMobile ? 4.7 : 5.0, distance: 260, level: 5 },
                { score: 2000, speed: isMobile ? 5.2 : 5.5, distance: 240, level: 6 },
                { score: 2500, speed: isMobile ? 5.7 : 6.0, distance: 220, level: 7 },
                { score: 3000, speed: isMobile ? 6.2 : 6.5, distance: 200, level: 8 },
                { score: 4000, speed: isMobile ? 6.7 : 7.0, distance: 180, level: 9 }
            ];
            
            // Augmenter la difficult√© selon le score
            for (const threshold of difficultyThresholds) {
                if (score >= threshold.score && difficultyLevel < threshold.level) {
                    gameSpeed = threshold.speed;
                    minObstacleDistance = threshold.distance;
                    difficultyLevel = threshold.level;
                    
                    // AJOUTEZ ICI - Son de niveau sup√©rieur
        AudioManager.playSound('levelUp');
                    
                    // Notification de changement de niveau
                    const levelUpNotice = document.createElement('div');
                    levelUpNotice.style.position = 'absolute';
                    levelUpNotice.style.top = '50%';
                    levelUpNotice.style.left = '50%';
                    levelUpNotice.style.transform = 'translate(-50%, -50%)';
                    levelUpNotice.style.color = '#FF5722';
                    levelUpNotice.style.fontWeight = 'bold';
                    levelUpNotice.style.fontSize = '28px';
                    levelUpNotice.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
                    levelUpNotice.style.zIndex = '50';
                    levelUpNotice.textContent = `Niveau ${threshold.level}!`;
                    
                    gameContainer.appendChild(levelUpNotice);
                    
                    // Animation de fondu
                    let opacity = 1;
                    const fadeOut = setInterval(() => {
                        opacity -= 0.05;
                        levelUpNotice.style.opacity = opacity;
                        
                        if (opacity <= 0) {
                            clearInterval(fadeOut);
                            if (levelUpNotice.parentNode) {
                                levelUpNotice.remove();
                            }
                        }
                    }, 50);
                    
                    break;
                }
            }
        }

        // Mettre √† jour les effets actifs
        function updateEffects() {
            if (isGameOver) return;
            
            // Gestion de l'invisibilit√©
            if (isInvisible) {
                invisibilityTimer--;
                invisibilityTime.textContent = invisibilityTimer;
                
                if (invisibilityTimer <= 0) {
                    isInvisible = false;
                    samoussa.classList.remove('invisible');
                    invisibilityEffect.style.display = 'none';
                }
            }
        }

        // Activer l'effet d'invisibilit√©
        function activateInvisibility() {
            isInvisible = true;
            invisibilityTimer = invisibilityDuration;
            invisibilityTime.textContent = invisibilityTimer;
            samoussa.classList.add('invisible');
            invisibilityEffect.style.display = 'block';
        }

        // Effet boost am√©lior√© quand on prend la bi√®re
        function showBoostEffect() {
            // Positionner l'effet sous le samoussa
            const samoussaRect = samoussa.getBoundingClientRect();
            const centerX = samoussaRect.left + (samoussaRect.width / 2);
            
            boostEffect.style.display = 'block';
            boostEffect.style.left = centerX + 'px';
            boostEffect.style.bottom = samoussa.style.bottom;
            
            // Arr√™ter toute animation pr√©c√©dente
            if (window.boostAnimation) {
                clearTimeout(window.boostAnimation);
            }
            
            // Garder l'effet visible pendant 1 seconde
            window.boostAnimation = setTimeout(() => {
                boostEffect.style.display = 'none';
            }, 1000);
        }

        // Mettre √† jour le jeu √† chaque frame
        function updateGame(timestamp) {
            if (isGameOver) return;
            
            // Gestion du temps entre les frames
            if (!lastFrameTime) lastFrameTime = timestamp;
            const deltaTime = timestamp - lastFrameTime;
            
            // Limiter la fr√©quence pour une vitesse constante
            if (deltaTime < frameInterval) {
                requestAnimationFrame(updateGame);
                return;
            }
            
            // Facteur de mouvement bas√© sur le temps √©coul√©
            const speedFactor = deltaTime / frameInterval;
            const moveAmount = gameSpeed * speedFactor;
            
            lastFrameTime = timestamp;
            
            // D√©placer les obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position -= moveAmount;
                obstacle.element.style.left = obstacle.position + 'px';
                
                // Supprimer les obstacles hors √©cran
                if (obstacle.position < -60) {
                    obstacle.element.remove();
                    obstacles.splice(i, 1);
                    continue;
                }
                
                // V√©rifier les collisions si pas invisible
                if (!isInvisible) {
                    if (checkCollision(samoussa, obstacle.element)) {
                        gameOver();
                        return;
                    }
                }
            }
            
            // D√©placer les collectibles
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                collectible.position -= moveAmount;
                collectible.element.style.left = collectible.position + 'px';
                
                // Supprimer les collectibles hors √©cran
                if (collectible.position < -50) {
                    collectible.element.remove();
                    collectibles.splice(i, 1);
                    continue;
                }
                
                // V√©rifier les collisions
                if (checkCollision(samoussa, collectible.element)) {
                    // Incr√©menter le combo
                    incrementCombo();
                    lastCollectTime = Date.now();
                    
                    // AJOUTEZ ICI - Son de collecte
    if (collectible.type === 'biere') {
        AudioManager.playSound('powerup');
    } else {
        AudioManager.playSound('collect');
    }
                    
                    // Points de base selon le type
                    let basePoints = 10;
                    
                    // Effet selon le type de collectible
                    if (collectible.type === 'biere') {
                        activateInvisibility();
                        basePoints = 20;
                        showBoostEffect();
                        
                        // Vibration sur mobile si support√©
                        if (isMobile && navigator.vibrate) {
                            navigator.vibrate(100);
                        }
                    } else if (collectible.type === 'piment') {
                        basePoints = 15;
                    }
                    
                    // Appliquer le multiplicateur de combo
                    const pointsGained = basePoints * comboMultiplier;
                    score += pointsGained;
                    
                    scoreElement.textContent = score;
                    collectible.element.remove();
                    collectibles.splice(i, 1);
                    
                    // Animation de collecte am√©lior√©e
                    const collectEffect = document.createElement('div');
                    collectEffect.className = 'collect-effect';
                    collectEffect.style.left = collectible.position + 'px';
                    collectEffect.style.bottom = collectible.bottom + 'px';
                    
                    // Message selon le type et combo
                    if (collectible.type === 'biere') {
                        collectEffect.textContent = `+${pointsGained} INVISIBLE!`;
                        collectEffect.style.color = '#FF9800';
                    } else if (collectible.type === 'piment') {
                        collectEffect.textContent = `+${pointsGained}`;
                        collectEffect.style.color = '#F44336';
                    } else {
                        collectEffect.textContent = `+${pointsGained}`;
                    }
                    
                    // Faire grossir l'effet en fonction du combo
                    if (comboMultiplier > 1) {
                        collectEffect.style.fontSize = (4 + (comboMultiplier * 0.5)) + 'vmin';
                    }
                    
                    gameContainer.appendChild(collectEffect);
                    
                    // Animation de flottement et disparition
                    setTimeout(() => {
                        collectEffect.style.transform = 'translateY(-50px)';
                        collectEffect.style.opacity = '0';
                    }, 50);
                    
                    setTimeout(() => {
                        if (collectEffect.parentNode) {
                            collectEffect.remove();
                        }
                    }, 1000);
                }
            }
            
            requestAnimationFrame(updateGame);
        }
        
        // Nouvelle fonction de boucle de jeu unifi√©e
function gameLoop(timestamp) {
    if (isGameOver) return;
    
    if (!lastFrameTime) lastFrameTime = timestamp;
    const deltaTime = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    // Mise √† jour des obstacles (environ chaque 100ms)
    if (timestamp - lastObstacleCheckTime > 100) {
        // Mettre √† jour le temps de jeu
        gameTime += timestamp - lastObstacleCheckTime;
        
        // G√©n√©rer les obstacles
        if (gameTime >= nextObstacleTime) {
            // V√©rifier s'il est trop t√¥t pour g√©n√©rer de nouveaux obstacles doubles
            const tooSoonForDoubleObstacle = (gameTime - lastDoubleObstacleTime < doubleObstacleRestPeriod);
            
            // Si des obstacles doubles ont √©t√© g√©n√©r√©s r√©cemment et niveau <= 6, forcer un obstacle simple
            if (difficultyLevel <= 6 && tooSoonForDoubleObstacle) {
                // Sauvegarder la valeur originale de createDouble
                const originalCreateDouble = Math.random() < 0.25 && difficultyLevel >= 4;
                
                // Temporairement forcer les obstacles simples
                const createDoubleBackup = window.createDoubleOverride;
                window.createDoubleOverride = true;
                
                // Appel √† createObstacle avec override
                createObstacle();
                
                // Restaurer l'√©tat
                window.createDoubleOverride = createDoubleBackup;
            } else {
                // Comportement normal
                createObstacle();
            }
            
            // Prochain obstacle avec d√©lai variable bas√© sur la difficult√©
            let minDelay = Math.max(1000, 1800 - ((difficultyLevel - 1) * 100));
            let maxAdditionalDelay = Math.max(500, 1500 - ((difficultyLevel - 1) * 150));
            
            // Si nous venons de g√©n√©rer un obstacle double, augmenter le d√©lai pour la prochaine g√©n√©ration
            if (gameTime - lastDoubleObstacleTime < 1000) {
                // Ajouter un d√©lai suppl√©mentaire apr√®s des obstacles doubles
                minDelay += 800;
                maxAdditionalDelay += 500;
            }
            
            nextObstacleTime = gameTime + minDelay + Math.random() * maxAdditionalDelay;
        }
        
        // G√©n√©rer les collectibles
        if (gameTime >= nextCollectibleTime) {
            createSafeCollectible();
            // Prochain collectible avec d√©lai variable
            const minDelay = 3000;
            const maxAdditionalDelay = 2000;
            nextCollectibleTime = gameTime + minDelay + Math.random() * maxAdditionalDelay;
        }
        
        // V√©rifier si le combo doit √™tre r√©initialis√© (temps √©coul√© depuis la derni√®re collecte)
        if (comboCount > 0 && Date.now() - lastCollectTime > comboDuration) {
            resetCombo();
        }
        
        lastObstacleCheckTime = timestamp;
    }
    
    // Mise √† jour du score (environ chaque 100ms)
    if (timestamp - lastScoreUpdateTime > 100) {
        updateScore();
        lastScoreUpdateTime = timestamp;
    }
    
    // Mise √† jour des effets (environ chaque seconde)
    if (timestamp - lastEffectsUpdateTime > 1000) {
        updateEffects();
        lastEffectsUpdateTime = timestamp;
    }
    
    // Animation du samoussa (environ chaque 200ms)
    if (timestamp - lastAnimationUpdateTime > 200) {
        animateSamoussa();
        lastAnimationUpdateTime = timestamp;
    }
    
    // Mise √† jour du jeu
    updateGame(timestamp);
    
    // Continuer la boucle
    requestAnimationFrame(gameLoop);
}

    function gameOver() {
    isGameOver = true;
    isJumping = false;
    isSpacePressed = false;
    isTouching = false;
           
    // AJOUTEZ ICI - Son de crash
    AudioManager.playSound('crash');
    
    // Cacher l'indicateur de puissance
    if (powerIndicator) {
        powerIndicator.style.display = 'none';
    }
    
    // Cacher l'indice de saut
    jumpHint.style.display = 'none';
    
    // Masquer le conteneur de combo
    document.getElementById('combo-container').style.display = 'none';
    
    // Mettre √† jour et afficher le tableau des meilleurs scores
    updateHighScores();
    document.getElementById('highscores').style.display = 'none'; // Masquer le tableau isol√©
    
    // Ajouter un paille-en-queue initial
    // Annuler l'animation de saut
    if (jumpAnimationId) {
        cancelAnimationFrame(jumpAnimationId);
        jumpAnimationId = null;
    }
    
    // Arr√™ter tous les intervalles
    if (window.gameIntervals) {
        Object.values(window.gameIntervals).forEach(interval => {
            clearInterval(interval);
        });
        // AJOUTER CE CODE ICI
        if (window.gameIntervals.pailleEnQueue) {
            clearInterval(window.gameIntervals.pailleEnQueue);
        }
    }
    
    // Arr√™ter le g√©n√©rateur de nuages
    if (cloudGeneratorInterval) {
        clearInterval(cloudGeneratorInterval);
        cloudGeneratorInterval = null;
    }
    
    // Animation de crash
    if (!document.body.classList.contains('fallback-mode')) {
        samoussa.style.backgroundImage = `url(${samoussaImages.crash})`;
    }
    samoussa.style.transform = 'rotate(45deg)';
    
    // Vibration sur mobile si support√©
    if (isMobile && navigator.vibrate) {
        navigator.vibrate([100, 50, 200]);
    }
    
    // Mettre √† jour les scores finaux
    finalScoreElement.textContent = score;
    document.getElementById('final-combo').textContent = `x${maxCombo}`;
    document.getElementById('final-level').textContent = difficultyLevel;
           
    // Masquer le conteneur de combo si le combo n'est pas significatif
    if (maxCombo <= 1) {
        document.getElementById('final-combo-container').style.display = 'none';
    } else {
        document.getElementById('final-combo-container').style.display = 'block';
    }

    // Ajuster dynamiquement la taille du texte si le score est tr√®s grand
    const finalScore = document.getElementById('final-score');
    if (score > 9999) {
        finalScore.style.fontSize = '0.9em';
    }

    // Adaptation pour les grands √©crans (comme iPhone 15)
    const screenHeight = window.innerHeight;
    const gameOverScreen = document.getElementById('game-over');
    if (screenHeight > 800) {
        gameOverScreen.classList.add('large-screen');
    } else {
        gameOverScreen.classList.remove('large-screen');
    }
    
    // G√©n√©rer un QR code si niveau suffisant (5+)
    // Supprimer l'ancienne section de r√©compense si elle existe
    const oldRewardSection = gameOverScreen.querySelector('.reward-section');
    if (oldRewardSection) {
        oldRewardSection.remove();
    }
    
    if (difficultyLevel >= 5) {
        const qrResult = generateRewardQR(score, difficultyLevel);
        
        if (qrResult) {
            // Cr√©er la section r√©compense
            const rewardSection = document.createElement('div');
            rewardSection.className = 'reward-section';
            
            // AJOUTER CE BLOC DE CODE CONDITIONNEL ICI
            if (qrResult.isLimited) {
                // Afficher un message de limite au lieu du QR
                if (qrResult.isPermanent) {
                    // Message pour limitation permanente (niveau 9)
                    rewardSection.innerHTML = `
                        <h3 class="reward-title">R√âCOMPENSE D√âJ√Ä OBTENUE</h3>
                        <p class="reward-text">${qrResult.message}</p>
                        <p class="reward-text">Cette r√©compense ne peut √™tre gagn√©e qu'une seule fois.</p>
                    `;
                } else {
                    // Message pour limitation mensuelle (autres niveaux)
                    rewardSection.innerHTML = `
                        <h3 class="reward-title">LIMITE ATTEINTE</h3>
                        <p class="reward-text">${qrResult.message}</p>
                        <p class="reward-text">R√©essayez dans ${qrResult.remainingDays} jours.</p>
                    `;
                }
            } else {
                // R√©compense normale avec QR code
                rewardSection.innerHTML = `
                    <h3 class="reward-title">F√âLICITATIONS!</h3>
                    <p class="reward-text">Vous avez gagn√©:</p>
                    <p class="reward-text"><strong>${qrResult.reward}</strong></p>
                    <div class="qr-container">${qrResult.html}</div>
                    <p class="code-text">Code: ${qrResult.code}</p>
                    <p class="expiry">Valable jusqu'au ${qrResult.expiryDate}</p>
                    
                    <button id="email-button" class="email-button">
                        üìß Recevoir par email
                    </button>
                    
                    <p class="screenshot-hint">üì± Ou faites une capture d'√©cran de ce QR code ! üì±</p>
                `;
                
                // Ajouter l'√©v√©nement au bouton apr√®s l'avoir cr√©√©
setTimeout(() => {
    const emailButton = document.getElementById('email-button');
    if (emailButton) {
        // Utiliser un gestionnaire onclick plus direct pour compatibilit√© maximale
        emailButton.onclick = function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            if (typeof window.showWayowayoEmailForm === 'function') {
                window.showWayowayoEmailForm();
            }
            return false;
        };
    }
}, 100);
            }
            
            // CONSERVER TOUT CE CODE EXISTANT TEL QUEL
            // Ajouter le tableau des meilleurs scores dans la section r√©compense
            const highScoresElement = document.createElement('div');
            highScoresElement.innerHTML = `
                <h4 style="color: #FFD700; margin-top: 15px; margin-bottom: 5px;">Meilleurs scores:</h4>
                <ol style="text-align: left; padding-left: 25px; margin-top: 5px;">
                    ${highScores.map(score => `<li>${score}</li>`).join('')}
                </ol>
            `;
            rewardSection.appendChild(highScoresElement);
            
            // Ajouter un bouton rejouer directement dans la section r√©compense
            const replayButtonInReward = document.createElement('button');
            replayButtonInReward.className = 'btn';
            replayButtonInReward.style.fontSize = '4vmin'; // Plus petit
            replayButtonInReward.style.padding = '10px 20px'; // Plus petit
            replayButtonInReward.style.marginTop = '15px';
            replayButtonInReward.textContent = 'REJOUER';
            replayButtonInReward.addEventListener('click', restartGame);
            replayButtonInReward.addEventListener('touchstart', function(event) {
                event.preventDefault();
                restartGame();
            });
            rewardSection.appendChild(replayButtonInReward);
                
            // Ins√©rer avant le bouton de restart
            const restartButton = document.getElementById('restart-button');
            gameOverScreen.insertBefore(rewardSection, restartButton);
        }
    } else {
        // Pour les niveaux inf√©rieurs, afficher seulement les meilleurs scores
        const scoresSection = document.createElement('div');
        scoresSection.className = 'reward-section';
        scoresSection.innerHTML = `
            <h4 style="color: #FFD700; margin-top: 5px; margin-bottom: 10px;">Meilleurs scores:</h4>
            <ol style="text-align: left; padding-left: 25px; margin-top: 5px;">
                ${highScores.map(score => `<li>${score}</li>`).join('')}
            </ol>
            <p class="reward-text" style="margin-top: 15px;">Atteignez le niveau 5 pour gagner une r√©compense!</p>
        `;
        
        // Ins√©rer avant le bouton de restart
        const restartButton = document.getElementById('restart-button');
        gameOverScreen.insertBefore(scoresSection, restartButton);
    }
    
    setTimeout(() => {
        gameOverScreen.style.display = 'flex';
    }, 500);
    
    setTimeout(() => {
        // Si le niveau 5+ est atteint et QR code affich√©, ajouter un petit bouton rejeu flottant
        if (difficultyLevel >= 5) {
            const miniReplayButton = document.createElement('div');
            miniReplayButton.id = 'mini-replay-button';
            miniReplayButton.style.position = 'fixed';
            miniReplayButton.style.bottom = '20px';
            miniReplayButton.style.right = '20px';
            miniReplayButton.style.width = '50px';
            miniReplayButton.style.height = '50px';
            miniReplayButton.style.borderRadius = '50%';
            miniReplayButton.style.backgroundColor = '#ff6b6b';
            miniReplayButton.style.boxShadow = '0 3px 8px rgba(0,0,0,0.3)';
            miniReplayButton.style.display = 'flex';
            miniReplayButton.style.justifyContent = 'center';
            miniReplayButton.style.alignItems = 'center';
            miniReplayButton.style.fontSize = '24px';
            miniReplayButton.style.color = 'white';
            miniReplayButton.style.zIndex = '2000';
            miniReplayButton.innerHTML = '‚Üª'; // Symbole de rafra√Æchissement
            miniReplayButton.style.cursor = 'pointer';
            
            // Ajouter l'√©v√©nement click/touch
            miniReplayButton.addEventListener('click', restartGame);
            miniReplayButton.addEventListener('touchstart', function(e) {
                e.preventDefault();
                restartGame();
            });
            
            document.body.appendChild(miniReplayButton);
        }
    }, 600); // L√©g√®rement apr√®s l'affichage de l'√©cran game over
}
        
        // Fonction pour mettre √† jour les meilleurs scores
function updateHighScores() {
    // Ajouter le score actuel √† la liste seulement s'il est > 0
    if (score > 0) {
        highScores.push(score);
    }
    
    // Trier par ordre d√©croissant
    highScores.sort((a, b) => b - a);
    
    // Garder seulement les 5 meilleurs
    highScores = highScores.slice(0, 5);
    
    // S'assurer qu'il y a au moins 5 entr√©es pour l'affichage
    while (highScores.length < 5) {
        highScores.push(0);
    }
    
    // Sauvegarder dans le localStorage
    try {
        localStorage.setItem('wayowayoHighScores', JSON.stringify(highScores));
    } catch (e) {
        console.error("Erreur lors de la sauvegarde des scores:", e);
    }
}
        
        // Fonction pour partager le score sur les r√©seaux sociaux ou par message
function shareScore(platform) {
    const shareText = `Je viens de faire ${score} points dans Samoussa Runner sur le site du restaurant WAYOWAYO! Niveau atteint: ${difficultyLevel}, Meilleur combo: x${maxCombo}. Venez battre mon record!`;
    const shareUrl = 'https://lewayowayo.github.io/samoussa-runner/';
    let fullUrl = '';
    
    switch(platform) {
        case 'x':
            fullUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}`;
            break;
        case 'whatsapp':
            fullUrl = `https://wa.me/?text=${encodeURIComponent(shareText + ' ' + shareUrl)}`;
            break;
        case 'sms':
            if (isMobile) {
                fullUrl = `sms:?&body=${encodeURIComponent(shareText + ' ' + shareUrl)}`;
            } else {
                alert("Le partage par SMS n'est disponible que sur mobile.");
                return;
            }
            break;
    }
    
    if (fullUrl) {
        window.open(fullUrl, '_blank');
    }
}
        
        // Syst√®me de combo
        function incrementCombo() {
            comboCount++;
            comboMultiplier = Math.min(comboCount + 1, 5); // Maximum x5 multiplicateur
            
            // Mettre √† jour l'affichage du combo
            const comboContainer = document.getElementById('combo-container');
            const comboCountElement = document.getElementById('combo-count');
            
            comboContainer.style.display = 'block';
            comboCountElement.textContent = `x${comboMultiplier}`;
            
            // Effet visuel de pulsation
            comboContainer.classList.remove('combo-pulse');
            void comboContainer.offsetWidth; // Force reflow
            comboContainer.classList.add('combo-pulse');
            
            // Mise √† jour de la couleur en fonction du niveau de combo
            if (comboMultiplier >= 3) {
                comboContainer.style.color = '#FFD700'; // Or pour les combos √©lev√©s
                comboContainer.style.textShadow = '0 0 5px #FFD700';
            } else {
                comboContainer.style.color = '#ff6b6b'; // Couleur normale
                comboContainer.style.textShadow = 'none';
            }
            
            // Mettre √† jour le combo maximum
            if (comboMultiplier > maxCombo) {
                maxCombo = comboMultiplier;
            }
        }
        
        function resetCombo() {
            comboCount = 0;
            comboMultiplier = 1;
            
            // Masquer l'affichage du combo
            document.getElementById('combo-container').style.display = 'none';
        }
        
        // D√©sactiver le double-tap qui pourrait causer un zoom sur mobile
        document.addEventListener('touchend', function(e) {
            if (isGameStarted) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
    <script src="register-sw.js"></script>
    <script src="audio.js"></script>
    <script src="pwa-prompt.js"></script>
    <script>
// Ajustement automatique de la qualit√© du jeu en fonction des performances
function optimizeGamePerformance() {
    // D√©tecter si nous sommes sur un appareil Android
    const isAndroid = /Android/i.test(navigator.userAgent);
    // D√©tecter si nous sommes dans un navigateur (pas en PWA)
    const isPWA = window.matchMedia('(display-mode: standalone)').matches;
    
    // Si nous sommes sur Android dans un navigateur
    if (isAndroid && !isPWA) {
        console.log("Optimisation pour Android en mode navigateur");
        
        // 1. R√©duire la fr√©quence des nuages et des oiseaux
        if (window.gameIntervals && window.gameIntervals.pailleEnQueue) {
            clearInterval(window.gameIntervals.pailleEnQueue);
            window.gameIntervals.pailleEnQueue = setInterval(() => {
                if (!isGameOver) {
                    createPailleEnQueue();
                }
            }, 25000); // Augment√© de 15000ms √† 25000ms
        }
        
        // 2. Simplifier les effets visuels
        document.querySelector('.boost-effect').style.display = 'none';
        
        // 3. Optimiser les animations CSS
        const styleSheet = document.createElement('style');
        styleSheet.textContent = `
            @media screen and (-webkit-min-device-pixel-ratio:0) {
                .cloud, .paille-en-queue {
                    will-change: transform;
                    transform: translateZ(0);
                }
                
                .cocotier-feuille {
                    backface-visibility: hidden;
                }
                
                @keyframes float-cloud {
                    0% { transform: translateX(120%) translateZ(0); }
                    100% { transform: translateX(-120%) translateZ(0); }
                }
            }
        `;
        document.head.appendChild(styleSheet);
        
        // 4. R√©duire la complexit√© graphique si n√©cessaire
        if (window.devicePixelRatio > 2) {
            // Pour les √©crans √† tr√®s haute r√©solution
            const metaViewport = document.querySelector('meta[name=viewport]');
            if (metaViewport) {
                metaViewport.setAttribute('content', 'width=device-width, initial-scale=0.7, maximum-scale=0.7, user-scalable=no');
            }
        }
    }
}

// Appeler cette fonction au d√©marrage du jeu
document.addEventListener('DOMContentLoaded', function() {
    // Attendre que le jeu soit compl√®tement charg√©
    setTimeout(optimizeGamePerformance, 1000);
});
</script>
    <div id="pwa-prompt" class="overlay-screen" style="display: none;">
    <div class="logo-container">
        <img src="assets/ww.png" alt="WAYOWAYO" style="width: 60%; max-width: 200px;" />
    </div>
    <h2>Pour une meilleure exp√©rience</h2>
    <p>Ce jeu fonctionne mieux quand il est install√© sur votre √©cran d'accueil !</p>
    
    <div style="background-color: rgba(0, 0, 0, 0.2); padding: 15px; border-radius: 10px; margin: 20px 0;">
        <p style="font-weight: bold; color: #FFD700;">Comment installer :</p>
        
        <div id="android-install" style="display: none;">
            <p>1. Appuyez sur <strong>‚ãÆ</strong> (menu)</p>
            <p>2. Choisissez <strong>Ajouter √† l'√©cran d'accueil</strong></p>
        </div>
        
        <div id="ios-install" style="display: none;">
            <p>1. Appuyez sur <img src="assets/share-icon.png" style="width: 20px; vertical-align: middle;"> (partager)</p>
            <p>2. Faites d√©filer jusqu'√† <strong>Sur l'√©cran d'accueil</strong></p>
        </div>
    </div>
    
    <button class="btn" id="continue-browser">CONTINUER QUAND M√äME</button>
    <p style="color: #FF9800; margin-top: 15px; font-size: 0.8em;">Le jeu peut √™tre lent dans certains navigateurs</p>
</div>
    <script>
// Solution stricte pour la faille de s√©curit√©
document.addEventListener('visibilitychange', function() {
    // Si le jeu est en cours et que la page devient cach√©e
    if (document.hidden && typeof isGameStarted !== 'undefined' && isGameStarted && !isGameOver) {
        console.log("Changement d'onglet d√©tect√© - Arr√™t du jeu");
        
        // Forcer la fin du jeu
        gameOver();
        
        // Cr√©er un message sp√©cial de game over
        const gameOverScreen = document.getElementById('game-over');
        if (gameOverScreen) {
            // Rechercher le titre h2 du game over
            const h2Elements = gameOverScreen.getElementsByTagName('h2');
            if (h2Elements.length > 0) {
                h2Elements[0].textContent = "PARTIE INTERROMPUE";
            }
            
            // Ajouter un message explicatif
            const explanationMessage = document.createElement('p');
            explanationMessage.style.color = '#FF9800';
            explanationMessage.style.fontWeight = 'bold';
            explanationMessage.textContent = "Le jeu s'arr√™te si vous changez d'onglet ou d'application.";
            
            // Ins√©rer apr√®s le titre
            if (h2Elements.length > 0) {
                h2Elements[0].parentNode.insertBefore(explanationMessage, h2Elements[0].nextSibling);
            } else {
                // Ins√©rer au d√©but si pas de titre
                gameOverScreen.insertBefore(explanationMessage, gameOverScreen.firstChild);
            }
        }
    }
});

// Ajouter un gestionnaire pour les changements d'application
window.addEventListener('blur', function() {
    // Si le jeu est en cours et que la fen√™tre perd le focus
    if (typeof isGameStarted !== 'undefined' && isGameStarted && !isGameOver) {
        console.log("Changement d'application d√©tect√© - Arr√™t du jeu");
        gameOver();
    }
});
</script>
    <script>

document.addEventListener('DOMContentLoaded', function() {
    const audioButton = document.getElementById('audio-controls');
    const soundIcon = document.getElementById('sound-icon');
    
    if (audioButton && soundIcon) {
        // Supprimer les gestionnaires existants pour √©viter les conflits
        audioButton.replaceWith(audioButton.cloneNode(true));
        
        // R√©cup√©rer la r√©f√©rence au nouvel √©l√©ment clon√©
        const newAudioButton = document.getElementById('audio-controls');
        const newSoundIcon = document.getElementById('sound-icon');
        
        function toggleAudio(e) {
    // Arr√™ter la propagation et l'action par d√©faut
    e.preventDefault();
    e.stopPropagation();
    
    console.log("Bouton audio cliqu√©");
    
    if (typeof AudioManager !== 'undefined') {
        // M√©moriser l'√©tat actuel avant de le changer
        const wasMuted = AudioManager.isMuted;
        
        // Utiliser la fonction toggleMute d'AudioManager
        const isMuted = AudioManager.toggleMute();
        
        // Mettre √† jour l'ic√¥ne
        newSoundIcon.src = isMuted ? 'assets/sound-off.png' : 'assets/sound-on.png';
        newSoundIcon.alt = isMuted ? 'Son d√©sactiv√©' : 'Son activ√©';
        
        console.log("Son " + (isMuted ? "d√©sactiv√©" : "activ√©"));
        
        // Si on vient de r√©activer le son (√©tait muet, n'est plus muet)
        if (wasMuted && !isMuted) {
            // Petit d√©lai pour laisser AudioManager terminer ses op√©rations
            setTimeout(() => {
                if (AudioManager.currentMusicPath) {
                    console.log("Relance forc√©e de la musique de fond");
                    AudioManager.playMusic(AudioManager.currentMusicPath);
                }
            }, 100);
        }
    } else {
        console.error("AudioManager non trouv√©");
    }
    
    return false;
}
        
        // Ajouter des gestionnaires pour diff√©rents types d'√©v√©nements
        newAudioButton.addEventListener('click', toggleAudio);
        newAudioButton.addEventListener('touchstart', toggleAudio, { passive: false });
        
        // Ajouter un effet visuel au toucher
        newAudioButton.addEventListener('touchstart', function() {
            this.style.opacity = '0.7';
        }, { passive: true });
        
        newAudioButton.addEventListener('touchend', function() {
            this.style.opacity = '1';
            // Ne pas appeler toggleAudio ici car touchstart le fera d√©j√†
        }, { passive: true });
        
        console.log("Gestionnaire audio am√©lior√© install√©");
    }
});
</script>
    <script>
// D√©tecter Safari et afficher le message PWA
document.addEventListener('DOMContentLoaded', function() {
    // D√©tecter si c'est Safari et pas d√©j√† en mode PWA
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    const isPWA = window.matchMedia('(display-mode: standalone)').matches;
    
    if (isSafari && !isPWA) {
        document.getElementById('safari-pwa-prompt').style.display = 'block';
    }
    
    // V√©rifier si le bouton REJOUER est visible
    const checkButtonVisibility = function() {
        const button = document.getElementById('restart-button');
        const rect = button.getBoundingClientRect();
        
        // Si le bouton est partiellement hors √©cran
        if (rect.bottom > window.innerHeight) {
            // Ajuster le padding du game-over pour s'assurer que tout est visible
            const gameOver = document.getElementById('game-over');
            const currentPadding = parseInt(window.getComputedStyle(gameOver).paddingBottom) || 0;
            gameOver.style.paddingBottom = (currentPadding + 20) + 'px';
        }
    };
    
    // V√©rifier la visibilit√© quand l'√©cran game-over s'affiche
    const gameOverScreen = document.getElementById('game-over');
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.attributeName === 'style' && 
                gameOverScreen.style.display !== 'none') {
                setTimeout(checkButtonVisibility, 100);
            }
        });
    });
    
    observer.observe(gameOverScreen, { attributes: true });
});
   </script>
    
   <!-- SOLUTION EMAIL WAYOWAYO - VERSION PWA COMPATIBLE -->
<div id="wayowayo-email-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); z-index: 9999;">
  <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 85%; max-width: 400px; background-color: #333; border-radius: 12px; padding: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);">
    <h3 style="color: #FFD700; text-align: center; margin-top: 0;">Recevoir votre code</h3>
    
    <p style="color: white; text-align: center; margin-bottom: 20px;">
      Saisissez votre email pour recevoir votre code QR
    </p>
    
    <input type="email" id="wayowayo-email-input" placeholder="Votre email" 
      style="width: 100%; padding: 12px; border-radius: 6px; border: none; margin-bottom: 15px; font-size: 16px; box-sizing: border-box;" />
    
    <div style="display: flex; gap: 10px;">
      <div id="wayowayo-cancel-btn" onclick="hideWayowayoEmailForm()"
        style="flex: 1; padding: 12px; background-color: #555; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; text-align: center; -webkit-tap-highlight-color: transparent; user-select: none;">
        Annuler
      </div>
      <div id="wayowayo-send-btn" onclick="submitWayowayoEmailForm()"
        style="flex: 1; padding: 12px; background-color: #4A89DC; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; text-align: center; -webkit-tap-highlight-color: transparent; user-select: none;">
        Envoyer
      </div>
    </div>
    
    <div id="wayowayo-status" style="margin-top: 15px; text-align: center; display: none; padding: 8px; border-radius: 5px;"></div>
  </div>
</div>

<script>
// SOLUTION EMAIL WAYOWAYO ULTRA SIMPLIFI√âE
// Variables globales - accessibles partout
var wayowayoEmailData = { code: '', reward: '', expiry: '', score: '', level: '' };

// Fonction pour extraire les donn√©es du QR code
function extractWayowayoQRData() {
    // Rechercher le code
    var code = '';
    var codeElement = document.querySelector('.code-text');
    if (codeElement) {
        code = codeElement.textContent.replace('Code:', '').replace('Code :', '').trim();
    } else {
        // Alternative: chercher dans tous les √©l√©ments
        var elements = document.getElementsByTagName('*');
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (el.textContent && el.textContent.includes('WY-') && el.textContent.includes('K-')) {
                var match = el.textContent.match(/WY-\d+K-[a-zA-Z0-9]+/);
                if (match && !code) {
                    code = match[0];
                    break;
                }
            }
        }
    }
    
    // R√©cup√©rer la r√©compense
    var reward = '';
    var rewardElement = document.querySelector('.reward-text strong');
    if (rewardElement) {
        reward = rewardElement.textContent.trim();
    } else {
        var level = document.getElementById('final-level') ? 
                    document.getElementById('final-level').textContent : '5';
        reward = getRewardTextForLevel(level);
    }
    
    // R√©cup√©rer la date d'expiration
    var expiry = '';
    var expiryElement = document.querySelector('.expiry');
    if (expiryElement) {
        expiry = expiryElement.textContent.replace('Valable jusqu\'au', '').trim();
    } else {
        var date = new Date();
        date.setDate(date.getDate() + 7);
        expiry = date.getDate() + '/' + (date.getMonth()+1) + '/' + date.getFullYear();
    }
    
    // R√©cup√©rer le score et le niveau
    var score = document.getElementById('final-score') ? 
                document.getElementById('final-score').textContent : '0';
    var level = document.getElementById('final-level') ? 
                document.getElementById('final-level').textContent : '5';
    
    return { code: code, reward: reward, expiry: expiry, score: score, level: level };
}

// Fonction pour obtenir le texte de r√©compense selon le niveau
function getRewardTextForLevel(level) {
    switch(level) {
        case '5': return '1 portion de samoussas offerte';
        case '6': return '2 portions de samoussas offertes';
        case '7': return '4 portions de samoussas offertes';
        case '8': return '1 repas complet pour 2 offert';
        case '9': return '1 an de samoussas offerts';
        default: return '1 portion de samoussas offerte';
    }
}

// Fonction pour afficher le formulaire email
function showWayowayoEmailForm() {
    // Extraire les donn√©es avant d'afficher
    wayowayoEmailData = extractWayowayoQRData();
    console.log("Donn√©es QR extraites:", wayowayoEmailData);
    
    // R√©cup√©rer l'email sauvegard√© si disponible
    try {
        var savedEmail = localStorage.getItem('wayowayoUserEmail');
        if (savedEmail) {
            document.getElementById('wayowayo-email-input').value = savedEmail;
        }
    } catch(e) {
        console.warn("Erreur localStorage:", e);
    }
    
    // Masquer le message de statut
    document.getElementById('wayowayo-status').style.display = 'none';
    
    // Afficher le formulaire
    document.getElementById('wayowayo-email-overlay').style.display = 'block';
    
    // Donner le focus au champ email apr√®s un court d√©lai
    setTimeout(function() {
        var input = document.getElementById('wayowayo-email-input');
        if (input) {
            input.focus();
            // Safari/iOS peut n√©cessiter un clic
            if ('ontouchstart' in window) {
                input.click();
            }
        }
    }, 300);
    
    // Configuration de la touche Entr√©e
    document.getElementById('wayowayo-email-input').onkeydown = function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            submitWayowayoEmailForm();
        }
    };
}

// Fonction pour cacher le formulaire
function hideWayowayoEmailForm() {
    document.getElementById('wayowayo-email-overlay').style.display = 'none';
}

// Fonction pour soumettre le formulaire
function submitWayowayoEmailForm() {
    // R√©cup√©rer et valider l'email
    var emailInput = document.getElementById('wayowayo-email-input');
    var statusDiv = document.getElementById('wayowayo-status');
    var email = emailInput.value.trim();
    
    if (!email || !email.includes('@') || !email.includes('.')) {
        statusDiv.textContent = "Email invalide";
        statusDiv.style.display = "block";
        statusDiv.style.backgroundColor = "rgba(231, 76, 60, 0.3)";
        statusDiv.style.color = "#e74c3c";
        return;
    }
    
    // Afficher l'√©tat d'envoi
    statusDiv.textContent = "Envoi en cours...";
    statusDiv.style.display = "block";
    statusDiv.style.backgroundColor = "rgba(243, 156, 18, 0.2)";
    statusDiv.style.color = "#f39c12";
    
    // Cr√©er le formulaire √† soumettre
    var form = document.createElement('form');
    form.method = 'POST';
    form.action = 'https://script.google.com/macros/s/AKfycbxozeZtrpTn6EUNmuU-UZpPeR6Rxq3yRG1yiVTbJNpVrJwBl_DsfSdH-qj0OQi9n-xq/exec';
    form.target = '_blank'; // Ouvrir dans un nouvel onglet pour √©viter de quitter le jeu
    form.style.display = 'none';
    
    // Ajouter tous les champs
    var fields = {
        'action': 'sendQRCodeEmail',
        'email': email,
        'code': wayowayoEmailData.code || 'CODE_NON_TROUV√â',
        'reward': wayowayoEmailData.reward || 'R√©compense WAYOWAYO',
        'expiry': wayowayoEmailData.expiry || '7 jours',
        'score': wayowayoEmailData.score || '0',
        'level': wayowayoEmailData.level || '5'
    };
    
    // Cr√©er les champs du formulaire
    for (var key in fields) {
        var input = document.createElement('input');
        input.type = 'hidden';
        input.name = key;
        input.value = fields[key];
        form.appendChild(input);
    }
    
    // Ajouter le formulaire √† la page
    document.body.appendChild(form);
    
    // Sauvegarder l'email (si possible)
    try {
        localStorage.setItem('wayowayoUserEmail', email);
    } catch(e) {
        console.warn("Impossible de sauvegarder l'email:", e);
    }
    
    // Soumettre le formulaire
    form.submit();
    console.log("Formulaire soumis avec donn√©es:", fields);
    
    // Afficher le message de succ√®s
    statusDiv.textContent = "Email envoy√© avec succ√®s !";
    statusDiv.style.display = "block";
    statusDiv.style.backgroundColor = "rgba(39, 174, 96, 0.3)";
    statusDiv.style.color = "#2ecc71";
    
    // Fermer le formulaire apr√®s un d√©lai
    setTimeout(function() {
        hideWayowayoEmailForm();
        // Nettoyer le formulaire
        if (form.parentNode) {
            form.parentNode.removeChild(form);
        }
    }, 2000);
}

// Attacher les gestionnaires aux boutons de l'interface
document.addEventListener('DOMContentLoaded', function() {
    // Mode ultra-simplifi√© avec des gestionnaires directs
    
    // Observer l'√©cran game-over pour ajouter les gestionnaires aux boutons email
    var gameOverScreen = document.getElementById('game-over');
    if (gameOverScreen) {
        var observer = new MutationObserver(function() {
            if (gameOverScreen.style.display !== 'none') {
                setTimeout(function() {
                    // Chercher tous les boutons d'email dans l'√©cran game-over
                    var emailButtons = document.querySelectorAll('[id*="email-button"], [class*="email-button"]');
                    emailButtons.forEach(function(btn) {
                        // R√©attacher directement le gestionnaire
                        btn.onclick = function(e) {
                            if (e) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            showWayowayoEmailForm();
                            return false;
                        };
                    });
                }, 300);
            }
        });
        
        observer.observe(gameOverScreen, { attributes: true });
    }
    
    // √Ä la cr√©ation de nouveaux boutons email, ajouter les gestionnaires
    setInterval(function() {
        var allEmailButtons = document.querySelectorAll('[id*="email-button"], [class*="email-button"]');
        allEmailButtons.forEach(function(btn) {
            if (!btn.wayowayoFixed) {
                btn.wayowayoFixed = true;
                btn.onclick = function(e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    showWayowayoEmailForm();
                    return false;
                };
            }
        });
    }, 1000);
});

// Attacher la fonction showWayowayoEmailForm √† window pour qu'elle soit accessible globalement
window.showWayowayoEmailForm = showWayowayoEmailForm;
</script>
    
    
    <!-- CORRECTIF POUR LE BOUTON EMAIL -->
<script>
// Ce script s'ex√©cutera apr√®s tout le reste et forcera le bouton √† fonctionner
document.addEventListener('DOMContentLoaded', function() {
    console.log("Correctif bouton email charg√©");
    
    // Fonction qui force l'attachement des gestionnaires d'√©v√©nements
    function forceEmailButtonFix() {
        // S√©lectionner sp√©cifiquement le bouton bleu d'email
        var emailButtons = document.querySelectorAll('.email-button, #email-button, [id*="email"], button:contains("email"), button:contains("Email")');
        
        emailButtons.forEach(function(button) {
            // Remplacer le bouton par une copie pour √©liminer tous les gestionnaires existants
            var newButton = button.cloneNode(true);
            if (button.parentNode) {
                button.parentNode.replaceChild(newButton, button);
            }
            
            // Ajouter nos gestionnaires directs
            newButton.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log("Bouton email cliqu√©!");
                
                // Appeler directement la fonction globale
                if (typeof window.showWayowayoEmailForm === 'function') {
                    window.showWayowayoEmailForm();
                } else {
                    // Fallback si la fonction n'est pas disponible
                    alert("Fonctionnalit√© temporairement indisponible. Veuillez faire une capture d'√©cran du QR code.");
                }
            });
            
            // Ajouter aussi un gestionnaire onclick pour plus de compatibilit√©
            newButton.onclick = function(e) {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                console.log("onclick du bouton email d√©clench√©!");
                
                if (typeof window.showWayowayoEmailForm === 'function') {
                    window.showWayowayoEmailForm();
                } else {
                    alert("Fonctionnalit√© temporairement indisponible. Veuillez faire une capture d'√©cran du QR code.");
                }
                return false;
            };
        });
        
        console.log("Nombre de boutons email corrig√©s: " + emailButtons.length);
    }
    
    // Ex√©cuter le correctif imm√©diatement
    setTimeout(forceEmailButtonFix, 500);
    
    // Et aussi apr√®s chaque affichage de l'√©cran game-over
    var gameOverScreen = document.getElementById('game-over');
    if (gameOverScreen) {
        var observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.attributeName === 'style' && 
                    gameOverScreen.style.display !== 'none') {
                    // L'√©cran game-over est devenu visible
                    setTimeout(forceEmailButtonFix, 200);
                    // Et encore une fois pour √™tre s√ªr
                    setTimeout(forceEmailButtonFix, 1000);
                }
            });
        });
        
        observer.observe(gameOverScreen, { attributes: true });
    }
    
    // Capturer globalement tous les clics sur des boutons qui pourraient √™tre des boutons email
    document.body.addEventListener('click', function(e) {
        var target = e.target;
        // V√©rifier si c'est un bouton email
        if (target && (
            (target.className && target.className.includes && target.className.includes('email')) ||
            (target.id && target.id.includes && target.id.includes('email')) ||
            (target.textContent && target.textContent.includes && target.textContent.toLowerCase().includes('email'))
        )) {
            e.preventDefault();
            e.stopPropagation();
            console.log("Clic global sur bouton email d√©tect√©!");
            
            // Appeler la fonction d'affichage du formulaire
            if (typeof window.showWayowayoEmailForm === 'function') {
                window.showWayowayoEmailForm();
            }
            return false;
        }
    }, true); // true pour la phase de capture
    
    // V√©rifier p√©riodiquement les boutons
    setInterval(forceEmailButtonFix, 2000);
});
</script>
    
    
</body>
</html>