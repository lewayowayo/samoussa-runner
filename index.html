<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Samoussa Runner - WAYOWAYO</title>
    <style>
        * {
            box-sizing: border-box;
            touch-action: manipulation;
        }
        html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
}
        body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: #f5f5f5;
    font-family: 'Arial', sans-serif;
    overflow: hidden;
    width: 100%;
    height: 100%;
}
        #game-container {
    position: relative;
    width: 100%;
    max-width: 800px;
    height: 100vh;
    max-height: none; /* Supprimer la restriction de hauteur */
    overflow: hidden;
    border: none;
    border-radius: 0;
    box-shadow: none;
    background: linear-gradient(to bottom, #87CEEB, #E0F7FA 70%, #bda79d 95%, #8B4513);
    z-index: 0;
}
        
        /* Logo WAYOWAYO */
        #logo-game {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px;
            height: auto;
            z-index: 5;
            opacity: 0.8;
        }
        
        /* Montagne estompée en arrière-plan - plus visible */
        .montagne {
            position: absolute;
            width: 100%;
            height: 25%;
            bottom: 15%;
            z-index: 1;
            overflow: hidden;
        }
        
        .montagne-forme {
            position: absolute;
            width: 300px;
            height: 120px;
            background: linear-gradient(to bottom, rgba(130, 145, 160, 0.5), rgba(130, 145, 160, 0));
            border-radius: 50% 50% 0 0;
            transform: scaleX(3);
        }
        
        .montagne-forme-1 {
            left: -5%;
            bottom: 0;
            height: 90px;
        }
        
        .montagne-forme-2 {
            left: 30%;
            bottom: 0;
            height: 110px;
            opacity: 0.7;
        }
        
        .montagne-forme-3 {
            left: 65%;
            bottom: 0;
            height: 80px;
            opacity: 0.8;
        }
        
        /* Nuages décoratifs */
        .cloud {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 50%;
            z-index: 1;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            filter: blur(1px);
        }
        
        /* Éléments décoratifs créoles */
        .creole-element {
            position: absolute;
            z-index: 2;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        
       /* REMPLACER TOUT LE CODE DES COCOTIERS PAR CELUI-CI */
.cocotier {
    /* Remplacez tout ce qui est ici */
    position: absolute;
    z-index: 2;
    opacity: 0.9;
    bottom: 15%;
    width: 60px;
    height: 170px;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}

.cocotier-tronc {
    /* Remplacez tout ce qui est ici */
    position: absolute;
    width: 10px;
    height: 100px;
    background: linear-gradient(to top, #8B5A2B, #A0522D);
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%) rotate(5deg);
    border-radius: 4px;
    z-index: 2;
}

.cocotier-feuilles {
    /* Remplacez tout ce qui est ici */
    position: absolute;
    bottom: 45px;
    left: -5%;
    transform: translateX(-50%) rotate(64deg);
    width: 150%;
    height: 80px;
    z-index: 3;
    pointer-events: none;
    will-change: transform;
}

.cocotier-feuille {
    position: absolute;
    width: 75px;
    height: 14px;
    background-color: #3CB371;
    border-radius: 100% 30% 100% 30% / 50%;
    transform-origin: right center;
    box-shadow: 0 2px 3px rgba(0,0,0,0.25);
    filter: drop-shadow(0 0 1px rgba(0,100,0,0.2));
    z-index: 3;
    pointer-events: none;
}

/* Position des feuilles individuelles inchangée */
.cocotier-feuille:nth-child(1) {
    transform: rotate(-15deg) translateX(-15px);
    top: 0;
    left: -5px;
}

.cocotier-feuille:nth-child(2) {
    transform: rotate(15deg) translateX(-15px);
    top: 0;
    left: -5px;
}

.cocotier-feuille:nth-child(3) {
    transform: rotate(-40deg) translateX(-12px);
    top: 0;
    left: -8px;
}

.cocotier-feuille:nth-child(4) {
    transform: rotate(40deg) translateX(-12px);
    top: 0;
    left: -8px;
}

.cocotier-feuille:nth-child(5) {
    transform: rotate(-65deg) translateX(-8px);
    top: 0;
    left: -10px;
}

.cocotier-feuille:nth-child(6) {
    transform: rotate(65deg) translateX(-8px);
    top: 0;
    left: -10px;
}

.cocotier-feuille:nth-child(7) {
    transform: rotate(-90deg) translateX(-4px);
    top: 0;
    left: -12px;
}

.cocotier-feuille:nth-child(8) {
    transform: rotate(90deg) translateX(-4px);
    top: 0;
    left: -12px;
}

/* GROUPE DE NOIX DE COCO */
.cocotier-noix {
    position: absolute;
    bottom: 85px;
    left: 50%;
    transform: translateX(-50%);
    width: 12px;
    height: 12px;
    background-color: #654321;
    border-radius: 50%;
    box-shadow: inset 1px -1px 3px rgba(255,255,255,0.3);
    z-index: 4; /* Supérieur au z-index des feuilles (3) */
}

.cocotier-noix-gauche {
    position: absolute;
    bottom: 80px;
    left: 40%;
    width: 10px;
    height: 10px;
    background-color: #654321;
    border-radius: 50%;
    box-shadow: inset 1px -1px 3px rgba(255,255,255,0.3);
    z-index: 4; /* Supérieur au z-index des feuilles (3) */
}

.cocotier-noix-droite {
    position: absolute;
    bottom: 82px;
    left: 60%;
    width: 11px;
    height: 11px;
    background-color: #654321;
    border-radius: 50%;
    box-shadow: inset 1px -1px 3px rgba(255,255,255,0.3);
    z-index: 4; /* Supérieur au z-index des feuilles (3) */
}

        /* Case créole améliorée */
        .case-creole {
    position: absolute;
    width: 100px; /* Augmenté de 80px à 100px */
    height: 65px; /* Augmenté de 50px à 65px */
    z-index: 2;
    bottom: 15%; /* Alignement avec le sol */
}

        .case-mur {
    position: absolute;
    width: 100%;
    height: 68%; /* Augmenté légèrement de 65% à 68% */
    bottom: -3px; /* Décalage négatif de 2px pour dépasser sous la case */
    background-color: #f9e4b7;
    border: 1px solid #654321;
    border-radius: 2px;
}

        .case-toit {
            position: absolute;
            width: 110%;
            height: 50%;
            top: -15%;
            left: -5%;
            background-color: #8B4513;
            clip-path: polygon(0 100%, 50% 0, 100% 100%);
            border-radius: 2px;
        }

        .case-porte {
    position: absolute;
    width: 25px;
    height: 28px;
    bottom: -3px; /* Décalage négatif de 2px pour dépasser sous la case */
    left: 50%;
    transform: translateX(-50%);
    background-color: #8B4513;
    border-radius: 2px 2px 0 0;
}

        .case-volet {
            position: absolute;
            width: 14px;
            height: 22px;
            background-color: #5272a1;
            border: 1px solid #444;
            border-radius: 1px;
            top: 30px;
        }

        .case-volet-gauche {
            left: 15px;
        }

        .case-volet-droite {
            right: 15px;
        }

        /* Motif en Z pour les volets */
        .case-volet::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 15%;
            top: 10%;
            left: 0;
            background-color: white;
        }

        .case-volet::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 15%;
            bottom: 10%;
            left: 0;
            background-color: white;
        }

        .case-volet-z {
            position: absolute;
            width: 140%;
            height: 15%;
            top: 42%;
            left: -20%;
            background-color: white;
            transform: rotate(32deg);
        }

        /* Ajuster l'échelle selon la taille de l'écran */
        @media (max-width: 767px) {
            .cocotier {
                transform: scale(0.9);
            }
            
            .case-creole {
                transform: scale(0.9);
            }
        }

        /* Réduire la hauteur du sol pour le remonter */
#ground {
    position: absolute;
    width: 100%;
    height: 30%;
    bottom: 0;
    background-color: rgba(141, 110, 99, 0.7);
    background-image: 
        linear-gradient(90deg, rgba(120, 90, 80, 0.15) 50%, transparent 50%),
        linear-gradient(rgba(120, 90, 80, 0.3) 1px, transparent 1px);
    background-size: 20px 100%, 100% 8px;
    box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.2);
    z-index: 2;
}

        #samoussa {
            position: absolute;
            width: 18%;  /* Augmenté significativement pour mobile */
            max-width: 100px;
            aspect-ratio: 1/1;
            bottom: 15%;
            left: 15%;
            z-index: 5;
            /* Style pour l'élément visuel */
            background-image: url('assets/samoussa_run1.png');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        /* Hitbox pour le samoussa */
        #samoussa::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 70%;
            top: 15%;
            left: 15%;
            border-radius: 35%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .obstacle {
            position: absolute;
            width: 16%;  /* Augmenté significativement pour mobile */
            max-width: 80px;
            aspect-ratio: 1/1;
            bottom: 15%;
            z-index: 4;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .obstacle.couteau {
            background-image: url('assets/couteau.png');
        }
        
        .obstacle.couteau::after {
            content: '';
            position: absolute;
            width: 60%;
            height: 70%;
            top: 15%;
            left: 20%;
            clip-path: polygon(0% 20%, 50% 100%, 100% 20%, 80% 0%, 20% 0%);
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .obstacle.marmite {
            background-image: url('assets/marmite.png');
        }
        
        .obstacle.marmite::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            top: 15%;
            left: 10%;
            border-radius: 50% 50% 20% 20%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .obstacle.main {
            background-image: url('assets/main.png');
        }
        
        .obstacle.main::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 90%;
            top: 5%;
            left: 15%;
            border-radius: 30% 30% 10% 10%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .collectible {
            position: absolute;
            width: 14%;  /* Augmenté significativement pour mobile */
            max-width: 60px;
            aspect-ratio: 1/1;
            z-index: 4;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .collectible.piment {
            background-image: url('assets/piment.png');
        }
        
        .collectible.piment::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 70%;
            top: 15%;
            left: 15%;
            border-radius: 50% 15% 50% 15%;
            transform: rotate(45deg);
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .collectible.epice {
            background-image: url('assets/epice.png');
        }
        
        .collectible.epice::after {
            content: '';
            position: absolute;
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
            border-radius: 10px;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        .collectible.biere {
            background-image: url('assets/biere_dodo.png');
            aspect-ratio: 5/6;
        }
        
        .collectible.biere::after {
            content: '';
            position: absolute;
            width: 70%;
            height: 80%;
            top: 10%;
            left: 15%;
            border-radius: 20% 20% 5% 5%;
            background-color: rgba(0, 0, 0, 0);
            z-index: -1;
        }

        /* Fallbacks en cas de problème de chargement */
        .fallback-mode #samoussa {
            background-image: none;
            background-color: #f3c669;
            border-radius: 35%;
        }
        
        .fallback-mode .obstacle.couteau {
            background-image: none;
            background-color: #a1a1a1;
            clip-path: polygon(0% 20%, 50% 100%, 100% 20%, 80% 0%, 20% 0%);
        }
        
        .fallback-mode .obstacle.marmite {
            background-image: none;
            background-color: #505050;
            border-radius: 50% 50% 10% 10%;
        }
        
        .fallback-mode .obstacle.main {
            background-image: none;
            background-color: #ffcba4;
            border-radius: 30% 30% 10% 10%;
        }
        
        .fallback-mode .collectible.piment {
            background-image: none;
            background-color: #ff3b30;
            border-radius: 50% 15% 50% 15%;
            transform: rotate(45deg);
        }
        
        .fallback-mode .collectible.epice {
            background-image: none;
            background-color: #ff9500;
            border-radius: 5px;
        }
        
        .fallback-mode .collectible.biere {
            background-image: none;
            background-color: #ffd700;
            border-radius: 20% 20% 5% 5%;
        }

        #score-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 4vmin;
            font-weight: bold;
            z-index: 10;
        }

        .status-effect {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 165, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 4vmin;
            font-weight: bold;
            z-index: 10;
            display: none;
        }

        .overlay-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.75));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }

        .logo-container {
            margin-bottom: 15px;
            max-width: 100%;
            padding: 0 10px;
        }
        
        #logo-accueil {
            width: 75%;
            max-width: 250px;
            height: auto;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.4));
            margin-top: -20px; /* Repositionné plus haut pour être entièrement visible */
        }
        
        .combo-explanation {
            background-color: rgba(255, 215, 0, 0.15);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 8px 15px;
            margin: 10px 0;
            font-size: 3vmin;
            max-width: 90%;
        }
        
        .combo-explanation strong {
            color: #FFD700;
            display: block;
            margin-bottom: 5px;
        }
        
        .combo-explanation p {
            margin: 5px 0;
        }
        
        @keyframes pulse-glow {
            0% { text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5); }
            50% { text-shadow: 0 0 10px rgba(255, 215, 0, 0.7), 0 0 20px rgba(255, 215, 0, 0.4); }
            100% { text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5); }
        }

        .btn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 5vmin;
            background-color: #ff6b6b;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 2000;
            position: relative;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover, .btn:active {
            background-color: #ff8c8c;
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .restaurant-info {
            width: 100%;
            font-size: 3vmin;
            color: white;
            text-align: center;
            margin-top: 30px;
            padding: 10px;
            background-color: rgba(255, 107, 107, 0.2);
            border-radius: 8px;
        }
        
        .restaurant-info p:last-child {
            font-style: italic;
            color: #FFD700;
        }

        .invisible {
            opacity: 0.5;
        }
        
       .power-indicator {
    position: absolute;
    bottom: 18%; /* Réduit de 25% à 18% pour l'abaisser un peu */
    left: 50%;
    transform: translateX(-50%);
    height: 10px;
    width: 50%;
    background-color: #333;
    border-radius: 5px;
    overflow: hidden;
    z-index: 100;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.15);
}
        
        .power-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #4CAF50, #FFC107, #F44336);
    transition: width 0.1s;
    box-shadow: inset 0 0 5px rgba(255,255,255,0.3);
}
        
        #combo-container {
            position: absolute;
            top: 60px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.6);
            padding: 10px;
            border-radius: 5px;
            font-size: 4vmin;
            font-weight: bold;
            color: #ff6b6b;
            z-index: 10;
            display: none;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .combo-pulse {
            animation: pulse 0.5s ease-in-out;
        }
        
        .collect-effect {
            position: absolute;
            color: #FFEB3B;
            font-weight: bold;
            font-size: 4vmin;
            z-index: 5;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s, opacity 0.5s;
        }
        
        #highscores {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 35%;
            max-width: 200px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 3vmin;
            z-index: 10;
        }
        
        #highscores h3 {
            margin: 0 0 10px 0;
            text-align: center;
            color: #ff6b6b;
            font-size: 3.5vmin;
        }
        
        #highscores ol {
            margin: 0;
            padding-left: 25px;
        }
        
        #highscores li {
            margin-bottom: 5px;
        }
        
        .share-buttons {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            gap: 10px;
        }
        
        .share-button {
            display: inline-block;
            padding: 12px 18px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 3.5vmin;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            margin: 0 5px;
            user-select: none;
            -webkit-tap-highlight-color: transparent; /* Supprime le surlignage sur tactile */
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .share-button:active {
            transform: scale(0.95);
        }

        .share-x {
            background-color: #000000;
        }
        
        .share-whatsapp {
            background-color: #25D366;
        }
        
        .share-sms {
            background-color: #3B82F6;
        }
        
        /* Effet de boost amélioré */
        .boost-effect {
            position: absolute;
            width: 150px;
            height: 60px;
            background: radial-gradient(ellipse at center, rgba(255, 165, 0, 0.7), rgba(255, 165, 0, 0) 70%);
            border-radius: 50%;
            z-index: 2;
            pointer-events: none;
            display: none;
            transform: translateX(-50%);
            animation: boost-pulse 0.8s infinite alternate;
        }
        
        @keyframes boost-pulse {
            0% { transform: translateX(-50%) scale(1); opacity: 0.7; }
            100% { transform: translateX(-50%) scale(1.2); opacity: 0.5; }
        }
        
        .overlay-screen > * {
            max-width: 90%;
            margin-left: auto;
            margin-right: auto;
        }
        
        #instructions {
            font-size: 3.5vmin;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            max-width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #instructions p {
            margin: 8px 0;
        }
        
        #instructions strong {
            color: #FFD700;
        }
        
        #jump-hint {
    position: absolute;
    bottom: 50%; /* Augmenter de 25% à 50% pour le placer bien au-dessus du samoussa */
    left: 50%;
    transform: translateX(-50%);
    color: white;
    background-color: rgba(0, 0, 0, 0.6);
    padding: 10px 15px;
    border-radius: 8px;
    font-size: 3.5vmin;
    z-index: 20;
    display: none;
    text-align: center;
    max-width: 80%;
    box-shadow: 0 3px 6px rgba(0,0,0,0.3);
}
        
        .hint-detail {
            font-size: 3vmin;
            display: block;
            margin-top: 5px;
            color: #FFD700;
            opacity: 0.9;
        }
        
        @media (orientation: landscape) {
            #game-container {
                height: 85vh;
                max-height: 500px;
            }
        }
        
        @media (max-height: 500px) {
            .restaurant-info {
                font-size: 2.5vmin;
                margin-top: 15px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 4vmin;
                margin-top: 10px;
            }
        }
        
        /* Animation nuages */
        @keyframes float-cloud {
            0% { transform: translateX(120%); }
            100% { transform: translateX(-120%); }
        }
        
        /* Animation volets */
        @keyframes sway {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(2deg); }
            100% { transform: rotate(0deg); }
        }
        
        /* Ajouter une classe de debug pour visualiser les hitboxes */
        .debug-mode .obstacle::after,
        .debug-mode .collectible::after,
        .debug-mode #samoussa::after {
            background-color: rgba(255, 0, 0, 0.5) !important;
        }
        /* Styles pour la section de récompense */
.reward-section {
    background-color: rgba(255, 215, 0, 0.2);
    border: 2px solid #FFD700;
    border-radius: 10px;
    padding: 15px;
    margin: 15px 0;
    animation: glow 1.5s infinite alternate;
    max-width: 90%;
}

.qr-container {
    background-color: white;
    padding: 10px;
    border-radius: 8px;
    display: inline-block;
    margin: 10px 0;
}

.reward-title {
    color: #FFD700;
    margin-bottom: 5px;
    font-size: 5vmin;
}

.reward-text {
    color: white;
    font-size: 4vmin;
    margin: 5px 0;
}

.code-text {
    font-family: monospace;
    font-size: 3.5vmin;
    background: rgba(0,0,0,0.7);
    padding: 5px;
    border-radius: 5px;
    display: inline-block;
    margin-top: 5px;
}

.expiry {
    font-size: 3vmin;
    color: #FF9800;
    margin-top: 8px;
}
        /* Styles spécifiques pour le message desktop */
#desktop-message h2 {
    color: #FF5722;
    margin-bottom: 20px;
    animation: pulse 1.5s infinite alternate;
}

#desktop-message p {
    font-size: 4.5vmin;
    max-width: 80%;
    margin: 10px auto;
}

#desktop-message img {
    margin-bottom: 30px;
}
        /* Ajoutez le nouveau style juste ici */
.screenshot-hint {
    margin-top: 10px;
    font-weight: bold;
    color: #FFD700;
    font-size: 3.5vmin;
    animation: pulse 1.5s infinite alternate;
}

@keyframes glow {
    from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); }
    to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
}
        /* Styles pour le paille-en-queue */
.paille-en-queue {
    position: absolute;
    top: 25%; /* Modifié de 10% à 25% */
    left: -80px;
    width: 60px;
    height: 22px;
    z-index: 3;
    animation: vol-oiseau 25s linear infinite;
    pointer-events: none;
}

.paille-corps {
    position: absolute;
    width: 32px;
    height: 12px;
    background-color: white;
    border-radius: 50% 60% 60% 40%;
    top: 5px;
    left: 0;
}

.paille-tete {
    position: absolute;
    width: 12px;
    height: 10px;
    background-color: white;
    border-radius: 50%;
    top: 4px;
    left: 30px;
}

.paille-bec {
    position: absolute;
    width: 10px;
    height: 4px;
    background-color: #FFCC00;
    border-radius: 0 50% 50% 0;
    top: 7px;
    left: 41px;
}

.paille-aile {
    position: absolute;
    width: 36px;
    height: 8px;
    background-color: white;
    border-radius: 70% 30% 90% 10%; /* Inverser la courbure */
    transform-origin: 80% 50%; /* Changer l'origine de transformation vers l'arrière */
    animation: battement-ailes 2s infinite alternate ease-in-out;
}


.paille-aile-haute {
    top: 2px;
    left: 8px;
    transform: rotate(-8deg);
}

.paille-aile-basse {
    top: 12px;
    left: 8px;
    transform: rotate(8deg);
}

.paille-aile::after {
    content: '';
    position: absolute;
    width: 12px;
    height: 3px;
    background-color: #333;
    left: 4px; /* Déplacer à gauche au lieu de droite */
    top: 3px;
    border-radius: 2px;
    opacity: 0.8;
}
        
.paille-queue {
    position: absolute;
    width: 70px;
    height: 3px;
    background-color: white;
    border-radius: 2px;
    top: 10px;
    left: -50px;
    transform-origin: right center;
    animation: ondulation-queue 3s infinite alternate ease-in-out;
}

@keyframes vol-oiseau {
    0% {
        left: -80px;
        top: 25%; /* Abaissé de 15% à 25% */
    }
    40% {
        top: 22%; /* Abaissé de 8% à 22% */
    }
    50% {
        top: 23%; /* Abaissé de 12% à 23% */
    }
    100% {
        left: calc(100% + 80px);
        top: 25%; /* Abaissé de 10% à 25% */
    }
}

@keyframes battement-ailes {
    0% {
        transform: rotate(8deg); /* Angle inversé */
    }
    100% {
        transform: rotate(15deg); /* Angle inversé */
    }
}

.paille-aile-basse {
    animation-name: battement-ailes-bas;
}

@keyframes battement-ailes-bas {
    0% {
        transform: rotate(-8deg); /* Angle inversé */
    }
    100% {
        transform: rotate(-15deg); /* Angle inversé */
    }
}

@keyframes ondulation-queue {
    0% {
        transform: rotate(0deg);
    }
    50% {
        transform: rotate(2deg);
    }
    100% {
        transform: rotate(-2deg);
    }
}
        #audio-controls {
    position: absolute;
    top: 130px; /* Position bien en-dessous du combo */
    left: 20px; /* Même alignement que le score */
    z-index: 150; /* z-index très élevé pour être sûr qu'il est au-dessus de tout */
    cursor: pointer;
    background-color: rgba(255, 255, 255, 0.8); /* Fond plus opaque */
    padding: 8px;
    border-radius: 8px;
    width: 44px;
    height: 44px;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2); /* Ombre pour mieux se détacher */
    -webkit-tap-highlight-color: transparent; /* Supprime le surlignage au toucher sur iOS */
}

#sound-icon {
    width: 32px;
    height: 32px;
    filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
}
/* Modifications pour l'écran Game Over */
#game-over {
    justify-content: flex-start; /* Aligner depuis le haut au lieu de centrer */
    padding-top: 10vh; /* Espace en haut de l'écran */
}

/* Logo container plus compact */
#game-over .logo-container {
    margin-bottom: 5px; /* Réduit de 15px à 5px */
    transform: scale(0.85); /* Réduire légèrement la taille */
}

/* Titres et textes plus compacts */
#game-over h2 {
    margin: 10px 0; /* Réduit les marges */
    font-size: 8vmin; /* Taille relative plus grande */
}

/* Regrouper les informations de score dans un container */
#game-over .score-info {
    display: flex;
    flex-direction: column;
    gap: 8px; /* Espace entre les lignes */
    margin: 5px 0 15px 0; /* Marges réduites */
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    width: 85%;
}

#game-over .score-info p {
    margin: 0; /* Supprimer marges par défaut */
    font-size: 5vmin; /* Taille relative à la largeur de l'écran */
}

/* Boutons de partage plus compacts */
#game-over .share-buttons {
    margin-top: 10px; /* Réduit de 20px à 10px */
}

/* Section de meilleurs scores plus compacte */
#game-over .reward-section {
    margin: 10px 0; /* Réduit de 15px à 10px */
    padding: 10px; /* Réduit de 15px à 10px */
    max-width: 85%; /* Légèrement plus étroit */
}

/* Pied de page plus compact */
#game-over .restaurant-info {
    margin-top: 10px; /* Réduit de 30px à 10px */
    font-size: 2.8vmin; /* Légèrement plus petit */
}

/* Cacher le combo si demandé */
#final-combo-container {
    display: none;
}

/* Ajustements pour les grands écrans (comme l'iPhone 15) */
@media screen and (min-height: 800px) {
    #game-over {
        padding-top: 8vh; /* Un peu moins d'espace en haut */
    }
    
    #game-over .score-info {
        gap: 12px; /* Plus d'espace entre les lignes */
    }
    
    #game-over .logo-container {
        margin-bottom: 10px; /* Un peu plus d'espace */
    }
}
        /* Ajustements Safari pour l'écran Game Over */
@supports (-webkit-touch-callout: none) {
    /* CSS spécifique pour Safari iOS */
    #game-over {
        padding-bottom: 100px; /* Espace supplémentaire en bas pour Safari */
        overflow-y: auto; /* Permettre le défilement si nécessaire */
        -webkit-overflow-scrolling: touch; /* Défilement doux pour iOS */
    }
    
    /* Réduire encore la taille de certains éléments */
    #game-over .logo-container {
        transform: scale(0.8);
        margin-bottom: 0;
    }
    
    #game-over h2 {
        margin: 5px 0;
        font-size: 7vmin;
    }
    
    #game-over .score-info {
        margin: 0 0 10px 0;
        padding: 8px;
    }
    
    /* Réduire la marge des boutons de partage */
    #game-over .share-buttons {
        margin-top: 5px;
        gap: 5px;
    }
    
    /* Ajustements pour la section des meilleurs scores */
    #game-over .reward-section {
        padding: 8px;
        margin: 5px 0;
    }
    
    /* Ajouter un message PWA pour Safari */
    #safari-pwa-prompt {
        display: block;
        font-size: 2.5vmin;
        color: #FFD700;
        margin: 5px 0;
        padding: 3px 8px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 5px;
        width: 80%;
        text-align: center;
    }
    
    /* S'assurer que le bouton Rejouer est bien visible */
    #restart-button {
        margin-top: 8px;
        padding: 12px 25px;
    }
    
    /* Ajuster la zone d'info restaurant */
    .restaurant-info {
        margin-top: 5px;
        padding: 5px;
    }
}

/* Réduire la taille pour les très petits écrans en hauteur (iPhone SE en paysage, etc.) */
@media screen and (max-height: 400px) {
    #game-over h2 {
        font-size: 6vmin;
        margin: 2px 0;
    }
    
    #game-over .score-info {
        gap: 4px;
        padding: 5px;
    }
    
    .share-button {
        padding: 8px 12px;
        font-size: 3vmin;
    }
    
    #restart-button {
        padding: 8px 20px;
        margin-top: 5px;
    }
}
        
    </style>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <!-- Ajoutez ces lignes dans la section <head> -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#ff6b6b">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Samoussa Runner">
<link rel="apple-touch-icon" href="icons/icon-152x152.png">

<!-- Liens pour les icônes iOS -->
<link rel="apple-touch-icon" sizes="72x72" href="ios/72.png">
<link rel="apple-touch-icon" sizes="96x96" href="ios/96.png">
<link rel="apple-touch-icon" sizes="128x128" href="ios/128.png">
<link rel="apple-touch-icon" sizes="144x144" href="ios/144.png">
<link rel="apple-touch-icon" sizes="152x152" href="ios/152.png">
<link rel="apple-touch-icon" sizes="192x192" href="ios/192.png">
<link rel="apple-touch-icon" sizes="384x384" href="ios/384.png">
<link rel="apple-touch-icon" sizes="512x512" href="ios/512.png">
</head>
<body>
    <div id="game-container">
        <div id="audio-controls">
    <img id="sound-icon" src="assets/sound-on.png" alt="Son activé" style="width: 30px; height: 30px; filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));">
</div>
                    <!-- Logo WAYOWAYO avec position optimisée -->
        <img id="logo-game" src="assets/ww.png" alt="WAYOWAYO" style="opacity: 0.95; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2))">
        
        <!-- Montagne estompée en arrière-plan -->
        <div class="montagne">
            <div class="montagne-forme montagne-forme-1"></div>
            <div class="montagne-forme montagne-forme-2"></div>
            <div class="montagne-forme montagne-forme-3"></div>
        </div>
        
        <div id="ground"></div>
        <div id="samoussa"></div>
        <div id="score-container">Score: <span id="score">0</span></div>
        <div id="combo-container">Combo: <span id="combo-count">x1</span></div>
        <div class="status-effect" id="invisibility-effect">Invisibilité: <span id="invisibility-time">0</span>s</div>
        <div class="boost-effect" id="boost-effect"></div>
        
        <!-- Tableau des meilleurs scores -->
        <div id="highscores">
            <h3>Meilleurs scores</h3>
            <ol id="highscore-list">
                <li>---</li>
                <li>---</li>
                <li>---</li>
                <li>---</li>
                <li>---</li>
            </ol>
        </div>
        
        <!-- Indicateur de saut pour appareils tactiles -->
        <div id="jump-hint">Tapez pour sauter !<br><span class="hint-detail">Appuyez longtemps pour sauter plus haut</span></div>
    </div>
    
    <!-- Écrans détachés -->
    <div id="start-screen" class="overlay-screen">
        <div class="logo-container">
            <img id="logo-accueil" src="assets/ww.png" alt="WAYOWAYO" />
        </div>
        <h2>Samoussa Runner</h2>
        <p>Aidez le samoussa à éviter les obstacles et à collecter les épices !</p>
        <p id="dodo-info" style="color: #FFD700; font-weight: bold; font-size: 4.2vmin; margin: 5px 0;">La bière Dodo te rend momentanément invincible!</p>
        
        <div id="instructions">
            <p>Sur mobile: <strong>Tapez sur l'écran</strong> pour sauter</p>
            <p>Sur ordinateur: <strong>ESPACE</strong> pour sauter</p>
            <p>Maintenez appuyé pour sauter plus haut!</p>
        </div>
        <button class="btn" id="start-button">JOUER</button>
        <div class="restaurant-info">
            <p>Restaurant Créole Réunionnais WAYOWAYO</p>
            <p>Venez déguster nos délicieux samoussas!</p>
        </div>
    </div>
    <div id="game-over" class="overlay-screen" style="display: none;">
    <div class="logo-container">
        <img id="logo-game-over" src="assets/ww.png" alt="WAYOWAYO" style="width: 60%; max-width: 200px;" />
    </div>
    <h2>GAME OVER</h2>
    
    <!-- Nouveau container pour regrouper les infos de score -->
    <div class="score-info">
        <p>Score final: <span id="final-score">0</span></p>
        <!-- Le combo est maintenant optionnel et caché par défaut -->
        <p id="final-combo-container">Meilleur combo: <span id="final-combo">x1</span></p>
        <p>Niveau atteint: <span id="final-level">1</span></p>
    </div>
    
    <!-- Boutons de partage -->
    <div class="share-buttons">
        <div class="share-button share-x" id="share-x-btn">X</div>
        <div class="share-button share-whatsapp" id="share-whatsapp-btn">WhatsApp</div>
        <div class="share-button share-sms" id="share-sms-btn">SMS</div>
    </div>
    <div id="safari-pwa-prompt" style="display: none;">
    Pour une meilleure expérience, ajoutez ce jeu à l'écran d'accueil 📱
</div>
    <button class="btn" id="restart-button">REJOUER</button>
    <div class="restaurant-info">
        <p>Restaurant Créole Réunionnais WAYOWAYO</p>
        <p>Venez déguster nos délicieux samoussas!</p>
    </div>
</div>
    
    <div id="desktop-message" class="overlay-screen" style="display: none;">
        <div class="logo-container">
            <img id="logo-desktop" src="assets/ww.png" alt="WAYOWAYO" style="width: 60%; max-width: 200px;" />
        </div>
        <h2>VERSION MOBILE UNIQUEMENT</h2>
        <p>Ce jeu est conçu exclusivement pour les appareils mobiles.</p>
        <p>Veuillez y accéder depuis votre smartphone ou tablette pour jouer à Samoussa Runner.</p>
        <div class="restaurant-info">
            <p>Restaurant Créole Réunionnais WAYOWAYO</p>
            <p>Venez déguster nos délicieux samoussas!</p>
        </div>
    </div>

    <script>
       // Détection du type d'appareil
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// Vérifier si c'est un appareil mobile ou desktop
document.addEventListener('DOMContentLoaded', function() {
    if (!isMobile) {
        // Masquer l'écran de démarrage normal
        document.getElementById('start-screen').style.display = 'none';
        // Afficher le message desktop
        document.getElementById('desktop-message').style.display = 'flex';
        // Masquer le conteneur de jeu
        document.getElementById('game-container').style.display = 'none';
    }
});

// Éléments du DOM
const gameContainer = document.getElementById('game-container');
        const samoussa = document.getElementById('samoussa');
        const scoreElement = document.getElementById('score');
        const finalScoreElement = document.getElementById('final-score');
        const gameOverScreen = document.getElementById('game-over');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const invisibilityEffect = document.getElementById('invisibility-effect');
        const invisibilityTime = document.getElementById('invisibility-time');
        const jumpHint = document.getElementById('jump-hint');
        const boostEffect = document.getElementById('boost-effect');
        const logoGame = document.getElementById('logo-game');
        
        // Fonction pour vérifier si le joueur peut générer une récompense
function canGenerateReward(level) {
    try {
        // Traitement spécial pour le niveau 9 - vérification permanente
        if (level >= 9) {
            // Vérifier si niveau 9 a déjà été gagné
            const level9Awarded = localStorage.getItem('level9RewardAwarded');
            if (level9Awarded === 'true') {
                return {
                    canGenerate: false,
                    message: "Vous avez déjà obtenu la récompense de niveau 9 auparavant.",
                    isPermanent: true
                };
            } else {
                // Marquer comme attribué de façon permanente
                localStorage.setItem('level9RewardAwarded', 'true');
                return { canGenerate: true };
            }
        }
        
        // Vérification mensuelle normale pour les autres niveaux
        const rewardHistory = JSON.parse(localStorage.getItem('rewardHistory') || '{}');
        const now = new Date();
        const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        
        if (!rewardHistory[currentMonth]) {
            rewardHistory[currentMonth] = {};
        }
        
        const currentMonthHistory = rewardHistory[currentMonth];
        const rewardKey = `level${level}`;
        const rewardCount = currentMonthHistory[rewardKey] || 0;
        
        // Limites mensuelles par niveau
        const monthlyLimits = {
            5: 2,  // Niveau 5: 2 codes par mois
            6: 2,  // Niveau 6: 2 codes par mois
            7: 1,  // Niveau 7: 1 code par mois
            8: 1   // Niveau 8: 1 code par mois
        };
        
        // Vérifier si la limite est atteinte
        if (rewardCount >= monthlyLimits[level]) {
            return {
                canGenerate: false,
                message: `Vous avez déjà généré le maximum de codes de niveau ${level} ce mois-ci.`,
                remainingDays: getDaysUntilNextMonth()
            };
        }
        
        // Mettre à jour l'historique
        currentMonthHistory[rewardKey] = rewardCount + 1;
        localStorage.setItem('rewardHistory', JSON.stringify(rewardHistory));
        
        return { canGenerate: true };
    } catch (e) {
        console.error("Erreur lors de la vérification des limites de récompense:", e);
        return { canGenerate: true }; // En cas d'erreur, permettre la génération
    }
}

// Fonction auxiliaire pour calculer les jours restants dans le mois
function getDaysUntilNextMonth() {
    const now = new Date();
    const lastDay = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
    return lastDay - now.getDate() + 1;
}
        
        // Fonction pour générer un QR code de récompense
function generateRewardQR(score, level) {
    // Déterminer la récompense selon le niveau
    let reward = "NONE";
    let rewardText = "";
    
    if (level < 5) {
        return null; // Aucune récompense pour niveaux inférieurs
    }
    
    // Vérifier si la génération est autorisée
    const checkResult = canGenerateReward(level);
    if (!checkResult.canGenerate) {
        // Retourner un objet spécial indiquant la limite
        return {
            isLimited: true,
            message: checkResult.message,
            isPermanent: checkResult.isPermanent,
            remainingDays: checkResult.remainingDays
        };
    }
    
    if (level >= 9) {
        reward = "1_AN_WAYOWAYO";
        rewardText = "1 an de WAYOWAYO offert ! (1 repas pour 2 par mois pendant 1 an)";
    } else if (level >= 8) {
        reward = "REPAS_COMPLET_2";
        rewardText = "1 repas complet pour 2 offert ! (entrées + plats + desserts + boissons)";
    } else if (level >= 7) {
        reward = "4_PORTIONS";
        rewardText = "4 portions de samoussas offertes!";
    } else if (level >= 6) {
        reward = "2_PORTIONS";
        rewardText = "2 portions de samoussas offertes!";
    } else if (level >= 5) {
        reward = "1_PORTION";
        rewardText = "1 portion de samoussas offerte!";
    } else {
        return null; // Aucune récompense pour niveaux inférieurs
    }

    // Créer un identifiant unique
    const now = new Date();
    const uniqueId = now.getTime().toString(36) + Math.random().toString(36).substring(2, 5).toUpperCase();

    // Créer la date d'expiration (7 jours plus tard)
    const expiryDateObj = new Date(now.getTime() + 7*24*60*60*1000);

    // Format ISO pour le QR code
    const expiryDateISO = expiryDateObj.toISOString().split('T')[0];
    const codeData = `WAYOWAYO:CODE=WY-${level}K-${uniqueId}:REWARD=${reward}:EXPIRES=${expiryDateISO}`;

    // Format français pour l'affichage (JJ/MM/AAAA)
    const expiryDateFR = `${expiryDateObj.getDate().toString().padStart(2, '0')}/${(expiryDateObj.getMonth() + 1).toString().padStart(2, '0')}/${expiryDateObj.getFullYear()}`;
    
    // Générer le QR code
    const qr = qrcode(0, 'L');
    qr.addData(codeData);
    qr.make();
    
    return {
        html: qr.createImgTag(5), // 5 = cell size
        code: `WY-${level}K-${uniqueId}`,
        reward: rewardText,
        expiryDate: expiryDateFR
    };
}

        // Gestion des assets et fallback
        function checkImagesLoaded() {
            const testImage = new Image();
            testImage.src = 'assets/samoussa_run1.png';
            testImage.onload = function() {
                console.log("Images chargées correctement");
            };
            testImage.onerror = function() {
                console.log("Impossible de charger les images, passage en mode fallback");
                document.body.classList.add('fallback-mode');
            };
        }
        
        // Fonction pour créer un cocotier amélioré - REMPLACER COMPLÈTEMENT
function createCocotier(x) {
    const cocotier = document.createElement('div');
    cocotier.className = 'cocotier';
    cocotier.style.left = x + '%';
    
    // Créer le tronc
    const tronc = document.createElement('div');
    tronc.className = 'cocotier-tronc';
    cocotier.appendChild(tronc);
    
    // Créer les feuilles
    const feuilles = document.createElement('div');
    feuilles.className = 'cocotier-feuilles';
    
    // Ajouter 8 feuilles pour un look plus fourni
    for (let i = 0; i < 8; i++) {
        const feuille = document.createElement('div');
        feuille.className = 'cocotier-feuille';
        feuilles.appendChild(feuille);
    }
    
    cocotier.appendChild(feuilles);
    
    // Ajouter trois noix de coco
    const noix = document.createElement('div');
    noix.className = 'cocotier-noix';
    cocotier.appendChild(noix);
    
    const noixGauche = document.createElement('div');
    noixGauche.className = 'cocotier-noix-gauche';
    cocotier.appendChild(noixGauche);
    
    const noixDroite = document.createElement('div');
    noixDroite.className = 'cocotier-noix-droite';
    cocotier.appendChild(noixDroite);
    
    gameContainer.appendChild(cocotier);
    
    return cocotier;
}
        
        // Fonction pour afficher un indice de stratégie de saut
function showJumpHint(position, strategy, duration = 1500, spacing = null) {
    
    // Jouer le son d'alerte approprié selon la stratégie
if (strategy === 'double') {
    // Son pour l'indice de double saut rapide
    AudioManager.playSound('hintDouble');
} else {
    // Son pour l'indice de saut long/maintenu
    AudioManager.playSound('hintLong');
}
    
    // Créer l'élément d'indice
    const hint = document.createElement('div');
    hint.className = 'jump-strategy-hint';
    
    // Styles de base
    hint.style.position = 'absolute';
    hint.style.zIndex = '10';
    hint.style.padding = '8px 12px';
    hint.style.borderRadius = '15px';
    hint.style.fontSize = '3.2vmin'; // Légèrement plus grand
    hint.style.fontWeight = 'bold';
    hint.style.color = 'white';
    hint.style.textShadow = '0 0 4px black, 0 0 2px rgba(0,0,0,0.8)'; // Ombre plus prononcée
    hint.style.opacity = '0.95'; // Plus visible
    hint.style.transition = 'opacity 0.4s, transform 0.6s';
    hint.style.textAlign = 'center';
    hint.style.userSelect = 'none';
    hint.style.pointerEvents = 'none';
    hint.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)'; // Ombre portée pour plus de contraste
    
    // Position initiale - au-dessus de la zone des obstacles
hint.style.bottom = (initialSamoussaBottom + 90) + 'px';
// S'assurer que l'indice reste toujours visible dans la zone de jeu
let leftPos = position;
const hintWidth = 150; // Largeur approximative de l'indice
const minLeft = 10; // Position minimale à gauche
const maxLeft = gameContainerWidth - hintWidth - 10; // Position maximale à gauche
leftPos = Math.max(minLeft, Math.min(maxLeft, leftPos)); // Limiter entre min et max
hint.style.left = leftPos + 'px';
    
    // Différencier visuellement les types de stratégie
    if (strategy === 'double') {
        // Stratégie de double saut rapide
        hint.style.backgroundColor = 'rgba(0, 173, 239, 0.85)';
        hint.style.border = '2px solid rgba(0, 120, 209, 1)';
        hint.textContent = '2 SAUTS RAPIDES!'; // Texte plus descriptif
        
        // Ajouter une icône
        const icon = document.createElement('div');
        icon.style.marginTop = '4px';
        icon.innerHTML = '↑ ↑';
        icon.style.fontSize = '3.5vmin';
        hint.appendChild(icon);
    } else {
        // Stratégie de saut long - visibilité renforcée
        hint.style.backgroundColor = 'rgba(76, 217, 100, 0.85)';
        hint.style.border = '2px solid rgba(46, 157, 70, 1)';
        hint.style.transform = 'scale(1.1)'; // Légèrement plus grand pour attirer l'attention
        hint.textContent = 'MAINTENIR APPUYÉ!'; // Plus clair sur l'action à faire
        
        // Ajouter une icône
        const icon = document.createElement('div');
        icon.style.marginTop = '4px';
        icon.innerHTML = '↗️ LONG ↘️';
        icon.style.fontSize = '3.5vmin';
        hint.appendChild(icon);
    }
    
    // Ajouter au conteneur de jeu
    gameContainer.appendChild(hint);
    
    // Animation d'apparition
    setTimeout(() => {
        hint.style.transform = strategy === 'single' ? 'translateY(-15px) scale(1.1)' : 'translateY(-15px)';
    }, 50);
    
    // Suppression automatique après la durée spécifiée
    setTimeout(() => {
        hint.style.opacity = '0';
        hint.style.transform = 'translateY(-30px) scale(0.9)';
        
        // Supprimer l'élément du DOM après la fin de l'animation
        setTimeout(() => {
            if (hint.parentNode) {
                hint.remove();
            }
        }, 300);
    }, duration);
    
    return hint;
}

        // Fonction pour créer une case créole améliorée
        function createCaseCreole(x) {
            const caseCreole = document.createElement('div');
            caseCreole.className = 'case-creole';
            caseCreole.style.left = x + '%';
            
            // Créer le mur
            const mur = document.createElement('div');
            mur.className = 'case-mur';
            caseCreole.appendChild(mur);
            
            // Créer le toit
            const toit = document.createElement('div');
            toit.className = 'case-toit';
            caseCreole.appendChild(toit);
            
            // Créer la porte
            const porte = document.createElement('div');
            porte.className = 'case-porte';
            caseCreole.appendChild(porte);
            
            // Créer les volets
            const voletGauche = document.createElement('div');
            voletGauche.className = 'case-volet case-volet-gauche';
            
            const voletDroite = document.createElement('div');
            voletDroite.className = 'case-volet case-volet-droite';
            
            // Ajouter les motifs Z aux volets
            const zGauche = document.createElement('div');
            zGauche.className = 'case-volet-z';
            voletGauche.appendChild(zGauche);
            
            const zDroite = document.createElement('div');
            zDroite.className = 'case-volet-z';
            voletDroite.appendChild(zDroite);
            
            caseCreole.appendChild(voletGauche);
            caseCreole.appendChild(voletDroite);
            
            gameContainer.appendChild(caseCreole);
            
            return caseCreole;
        }
        
        // Fonction pour créer un nuage
        function createCloud() {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            
            // Taille aléatoire mais légèrement plus grande
            const size = 40 + Math.random() * 50;
            cloud.style.width = size + 'px';
            cloud.style.height = size / 1.8 + 'px'; // Moins applati pour un look plus cotonneux
            
            // Position aléatoire (répartie sur toute la hauteur du ciel)
            const y = Math.random() * 25;
            cloud.style.top = y + '%';
            
            // Animation
            const speed = 35 + Math.random() * 35; // Vitesse légèrement plus lente
            cloud.style.animation = `float-cloud ${speed}s linear`;
            
            // Ajouter une deuxième div pour créer un effet de nuage plus réaliste
            const cloudDetail = document.createElement('div');
            cloudDetail.style.position = 'absolute';
            cloudDetail.style.width = (size * 0.7) + 'px';
            cloudDetail.style.height = (size / 2.2) + 'px';
            cloudDetail.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            cloudDetail.style.borderRadius = '50%';
            cloudDetail.style.bottom = '40%';
            cloudDetail.style.left = '15%';
            
            cloud.appendChild(cloudDetail);
            gameContainer.appendChild(cloud);
            
            // Supprimer le nuage une fois l'animation terminée
            cloud.addEventListener('animationend', function() {
                cloud.remove();
            });
            
            return cloud;
        }
        // Fonction pour créer un paille-en-queue
function createPailleEnQueue() {
    const paille = document.createElement('div');
    paille.className = 'paille-en-queue';
    
    // Varier légèrement la hauteur de vol
    const hauteurVol = 5 + Math.random() * 15;
    paille.style.top = hauteurVol + '%';
    
    // Appliquer un délai aléatoire à l'animation
    const delai = Math.random() * 12;
    paille.style.animationDelay = `-${delai}s`;
    
    // Corps
    const corps = document.createElement('div');
    corps.className = 'paille-corps';
    paille.appendChild(corps);
    
    // Tête
    const tete = document.createElement('div');
    tete.className = 'paille-tete';
    paille.appendChild(tete);
    
    // Bec
    const bec = document.createElement('div');
    bec.className = 'paille-bec';
    paille.appendChild(bec);
    
    // Ailes
    const aileHaute = document.createElement('div');
    aileHaute.className = 'paille-aile paille-aile-haute';
    paille.appendChild(aileHaute);
    
    const aileBasse = document.createElement('div');
    aileBasse.className = 'paille-aile paille-aile-basse';
    paille.appendChild(aileBasse);
    
    // Queue caractéristique du paille-en-queue
    const queue = document.createElement('div');
    queue.className = 'paille-queue';
    paille.appendChild(queue);
    
    gameContainer.appendChild(paille);
    
    // Supprimer l'oiseau une fois l'animation terminée
    paille.addEventListener('animationend', function() {
        paille.remove();
    });
    
    return paille;
}
        // Fonction pour nettoyer les pailles-en-queue existants
function clearAllPaillesEnQueue() {
    // Supprimer tous les oiseaux existants
    document.querySelectorAll('.paille-en-queue').forEach(oiseau => {
        oiseau.remove();
    });
}
        
        // Fonction pour générer des nuages à intervalles réguliers
        function startCloudGenerator() {
             // Nettoyer les oiseaux existants au démarrage du générateur
    clearAllPaillesEnQueue();
            // Générer quelques nuages au démarrage
            for (let i = 0; i < 3; i++) {
                const cloud = createCloud();
                // Position horizontale aléatoire pour les nuages initiaux
                cloud.style.left = (Math.random() * 100) + '%';
                cloud.style.animationPlayState = 'paused'; // Nuages statiques au démarrage
            }
            
            // Générer de nouveaux nuages à intervalles aléatoires
            return setInterval(() => {
                if (!isGameOver) {
                    createCloud();
                }
            }, 4000 + Math.random() * 3000);
        // Code à ajouter pour les pailles-en-queue
    let pailleEnQueueInterval = setInterval(() => {
        if (!isGameOver) {
            createPailleEnQueue();
        }
    }, 15000 + Math.random() * 10000);

    // Stocker l'intervalle
    window.gameIntervals.pailleEnQueue = pailleEnQueueInterval;
    
    return cloudGeneratorInterval;
}
        
        
        // Fonction mise à jour pour créer tous les éléments décoratifs
        function setupDecorativeElements() {
            // Créer des cocotiers de chaque côté de l'écran avec position ajustée
            createCocotier(12);   // Cocotier à gauche, un peu plus vers le centre
            createCocotier(82);  // Cocotier à droite, un peu plus vers le centre
            
            // Créer une case créole au milieu, posée sur le sol
            createCaseCreole(50);  // Centré parfaitement
        }

        // Vérifier si les images sont chargées
        checkImagesLoaded();
        
        // Mettre en place les éléments décoratifs
        setupDecorativeElements();
        
        // Démarrer le générateur de nuages
        let cloudGeneratorInterval = startCloudGenerator();

        // Le reste du code JavaScript reste inchangé
        // Variables du jeu et fonctions du jeu original
        let isJumping = false;
        let isGameOver = true;
        let isGameStarted = false;
        let isInvisible = false;
        let invisibilityTimer = 0;
        let invisibilityDuration = 5;
        let score = 0;
        let gameSpeed = 3.5;
        let maxGameSpeed = 7;
        let difficultyLevel = 1;
        let minObstacleDistance = 350;
        let lastObstaclePosition = 0;
        let gameTime = 0;
        let gameContainerWidth = gameContainer.clientWidth;
        // Variables pour la boucle de jeu unifiée
let lastFrameTime = 0;
let lastObstacleCheckTime = 0;
let lastCollectibleCheckTime = 0;
let lastScoreUpdateTime = 0;
let lastEffectsUpdateTime = 0;
let lastAnimationUpdateTime = 0;
        // Variable pour suivre le moment de la dernière génération d'obstacles doubles
let lastDoubleObstacleTime = 0;
// Temps de repos minimum entre deux groupes d'obstacles doubles (en millisecondes)
let doubleObstacleRestPeriod = 4000;
        
        // Variables pour le système de combo
        let comboMultiplier = 1;
        let comboCount = 0;
        let maxCombo = 1;
        let lastCollectTime = 0;
        const comboDuration = 7000; // Augmenté de 3000 à 7000 ms (7 secondes)
        
        // Récupérer les meilleurs scores depuis le localStorage
let highScores = [];
try {
    const savedScores = localStorage.getItem('wayowayoHighScores');
    if (savedScores) {
        highScores = JSON.parse(savedScores);
    } else {
        highScores = []; // Commencer avec une liste vide au lieu de [0,0,0,0,0]
    }
} catch (e) {
    console.error("Erreur lors de la récupération des scores:", e);
    highScores = [];
}
        
        // Variables du saut basé sur la pression
        let isSpacePressed = false;
        let isTouching = false;
        let touchStartTime = 0;
        let spacePressStartTime = 0;
        let maxPressTime = 800;
        let minJumpPower = 0.3;
        let jumpPower = minJumpPower;
        let powerIndicator = null;

        // Variables de saut
        let jumpTime = 0;
        let jumpDuration = 65;
        let jumpHeight = 150;
        let initialSamoussaBottom;
        let lastJumpTime = 0;
        let jumpAnimationId = null;
        
        // Variables pour gérer le timing entre les frames
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;

        // Images pour les animations
        const samoussaImages = {
            run1: 'assets/samoussa_run1.png',
            run2: 'assets/samoussa_run2.png',
            crash: 'assets/samoussa_crash.png'
        };
        
        // Types d'obstacles et de collectibles
        const obstacleTypes = ['couteau', 'marmite', 'main'];
        const collectibleTypes = ['piment', 'epice', 'biere'];
        let currentFrame = 0;
        
        // Tableaux pour stocker les éléments du jeu
        let obstacles = [];
        let collectibles = [];
        
        // Planification des éléments
        let nextObstacleTime = 3000;
        let nextCollectibleTime = 2000;
        
        // Adaptation mobile vs desktop
        if (isMobile) {
            // Afficher l'indice de saut pour mobile
            jumpHint.style.display = 'block';
            // Paramètres spécifiques au mobile
            maxPressTime = 500; // Plus court sur mobile
            
            // Ajuster la vitesse du jeu légèrement pour mobile
            gameSpeed = 3.2; // Un peu plus lent sur mobile
        }

        // Créer l'indicateur de puissance
        function createPowerIndicator() {
            powerIndicator = document.createElement('div');
            powerIndicator.className = 'power-indicator';
            powerIndicator.style.display = 'none';
            
            const powerBar = document.createElement('div');
            powerBar.className = 'power-bar';
            powerIndicator.appendChild(powerBar);
            
            gameContainer.appendChild(powerIndicator);
        }

        // S'assurer que l'écran de démarrage est visible au début
        startScreen.style.display = 'flex';
        samoussa.style.display = 'block';
        
        // Créer l'indicateur de puissance
        createPowerIndicator();
        
     function optimizeGameForFullscreen() {
    // Dimensions de base
    document.documentElement.style.height = '100%';
    document.body.style.height = '100%';
    
    // Récupérer les dimensions réelles de l'écran
    const windowHeight = window.innerHeight;
    const windowWidth = window.innerWidth;
    
    // Dimensions du conteneur
    gameContainer.style.width = '100%';
    gameContainer.style.height = '100vh';
    gameContainer.style.maxWidth = '800px';
    gameContainer.style.maxHeight = 'none';
    
    // Augmenter significativement la hauteur du sol (30% au lieu de 20%)
    const groundHeight = windowHeight * 0.30;
    initialSamoussaBottom = groundHeight;
    
    // Ajuster le sol
    const ground = document.getElementById('ground');
    ground.style.height = groundHeight + 'px';
    
    // Positionner le samoussa
    samoussa.style.bottom = initialSamoussaBottom + 'px';
    
    // Recalculer tous les obstacles
    obstacles.forEach(obstacle => {
        obstacle.element.style.bottom = initialSamoussaBottom + 'px';
    });
    
    // Repositionner tous les collectibles
    collectibles.forEach(collectible => {
        // Si le collectible était à une hauteur relative au sol
        const currentBottom = parseFloat(collectible.element.style.bottom);
        const bottomOffset = currentBottom - (windowHeight * 0.15);
        collectible.element.style.bottom = (groundHeight + bottomOffset) + 'px';
    });
    
    // Repositionner les éléments décoratifs
    document.querySelectorAll('.cocotier, .case-creole').forEach(element => {
        element.style.bottom = groundHeight + 'px';
    });
    
    // Mettre à jour la montagne
    const montagnes = document.querySelector('.montagne');
    if (montagnes) {
        montagnes.style.bottom = groundHeight + 'px';
    }
    
    
    // Mettre à jour la largeur pour les calculs
    gameContainerWidth = gameContainer.clientWidth;
    
    // Ajuster la hauteur de saut proportionnellement
    jumpHeight = windowHeight * 0.28;
}
        
       function resizeGame() {
    // Appeler la fonction d'optimisation plein écran
    optimizeGameForFullscreen();
    
    // Mettre à jour la largeur du conteneur pour les calculs internes
    gameContainerWidth = gameContainer.clientWidth;
    
    // Conserver la dynamique de jeu originale basée sur la hauteur
    jumpHeight = gameContainer.clientHeight * 0.3;
}
        
        // Appeler resize au chargement et au redimensionnement
        window.addEventListener('load', resizeGame);
        window.addEventListener('resize', resizeGame);

        // Événements pour clavier
        document.addEventListener('keydown', function(event) {
            // Démarrer le jeu avec la touche Entrée
            if ((event.code === 'Enter' || event.key === 'Enter') && !isGameStarted) {
                startGame();
                return;
            }
            
            // Commencer à charger le saut quand on appuie sur espace
            if ((event.code === 'Space' || event.key === ' ') && !isJumping && !isGameOver && isGameStarted && !isSpacePressed) {
                isSpacePressed = true;
                spacePressStartTime = Date.now();
                jumpPower = minJumpPower;
                
                // Commencer l'animation de charge
                startJumpCharge();
            }
        });
        
        document.addEventListener('keyup', function(event) {
            // Sauter quand on relâche la barre d'espace
            if ((event.code === 'Space' || event.key === ' ') && isSpacePressed && !isGameOver && isGameStarted) {
                const pressDuration = Date.now() - spacePressStartTime;
                const normalizedDuration = Math.min(pressDuration / maxPressTime, 1.0);
                
                // Calculer la puissance entre min et max
                jumpPower = minJumpPower + (1 - minJumpPower) * normalizedDuration;
                
                // Cacher l'indicateur de puissance
                if (powerIndicator) {
                    powerIndicator.style.display = 'none';
                }
                
                isSpacePressed = false;
                jump();
            }
        });
        
        // Événements tactiles pour mobile
        gameContainer.addEventListener('touchstart', function(event) {
            event.preventDefault(); // Empêcher le zoom/scroll
            
            // Si le jeu est déjà démarré, démarrer le chargement du saut
            if (isGameStarted && !isGameOver && !isJumping && !isTouching) {
                isTouching = true;
                touchStartTime = Date.now();
                jumpPower = minJumpPower;
                
                // Commencer l'animation de charge
                startJumpCharge();
                
                // Cacher l'indice après le premier saut
                jumpHint.style.display = 'none';
            }
        }, { passive: false });

        gameContainer.addEventListener('touchend', function(event) {
            // Sauter quand on relâche
            if (isTouching && !isGameOver && isGameStarted) {
                const pressDuration = Date.now() - touchStartTime;
                const normalizedDuration = Math.min(pressDuration / maxPressTime, 1.0);
                
                // Calculer la puissance entre min et max
                jumpPower = minJumpPower + (1 - minJumpPower) * normalizedDuration;
                
                // Cacher l'indicateur de puissance
                if (powerIndicator) {
                    powerIndicator.style.display = 'none';
                }
                
                isTouching = false;
                jump();
            }
        });
        
        // Empêcher le défilement de la page sur mobile
        document.addEventListener('touchmove', function(event) {
            if (isGameStarted && !isGameOver) {
                event.preventDefault();
            }
        }, { passive: false });
        
        // Clic dans le conteneur du jeu
        gameContainer.addEventListener('click', function(event) {
            // Si le jeu est déjà démarré, permettre de sauter en cliquant
            if (isGameStarted && !isGameOver && !isElementClicked(event.target, [startButton, restartButton])) {
                // Pour les clics simples, saut à 80% de puissance
                jumpPower = 0.8;
                jump();
                
                // Cacher l'indice après le premier saut
                jumpHint.style.display = 'none';
            }
        });

        // Démarrer le jeu avec un clic sur le bouton Jouer
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', restartGame);
        
        // Ajouter des événements tactiles spécifiques pour les boutons de l'écran de game over
        restartButton.addEventListener('touchstart', function(event) {
            event.preventDefault();
            restartGame();
        });
        
        // Configuration des boutons de partage
        function setupShareButtons() {
            // Bouton de partage sur X (Twitter)
            const shareXBtn = document.getElementById('share-x-btn');
            shareXBtn.addEventListener('click', function() {
                shareScore('x');
            });
            shareXBtn.addEventListener('touchstart', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(0.95)';
            });
            shareXBtn.addEventListener('touchend', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(1)';
                shareScore('x');
            });
            
            // Bouton de partage sur WhatsApp
            const shareWhatsappBtn = document.getElementById('share-whatsapp-btn');
            shareWhatsappBtn.addEventListener('click', function() {
                shareScore('whatsapp');
            });
            shareWhatsappBtn.addEventListener('touchstart', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(0.95)';
            });
            shareWhatsappBtn.addEventListener('touchend', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(1)';
                shareScore('whatsapp');
            });
            
            // Bouton de partage par SMS
            const shareSmsBtn = document.getElementById('share-sms-btn');
            shareSmsBtn.addEventListener('click', function() {
                shareScore('sms');
            });
            shareSmsBtn.addEventListener('touchstart', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(0.95)';
            });
            shareSmsBtn.addEventListener('touchend', function(event) {
                event.preventDefault();
                this.style.transform = 'scale(1)';
                shareScore('sms');
            });
        }
        
        // Initialiser les boutons de partage au chargement
        document.addEventListener('DOMContentLoaded', setupShareButtons);

        // Vérifier si un élément cliqué est dans une liste d'éléments
        function isElementClicked(element, elementList) {
            return elementList.some(el => el === element || el.contains(element));
        }

        // Animation de chargement du saut avec indicateur visuel
        function startJumpCharge() {
            if ((!isSpacePressed && !isTouching) || isJumping || isGameOver) return;
            
            // Animer le samoussa pour indiquer le chargement
            const currentTime = Date.now();
            const pressStart = isSpacePressed ? spacePressStartTime : touchStartTime;
            const progress = Math.min((currentTime - pressStart) / maxPressTime, 1.0);
            
            // Actualiser la puissance du saut
            jumpPower = minJumpPower + ((1 - minJumpPower) * progress);
            
            // Mettre à jour l'indicateur visuel de puissance
            if (powerIndicator) {
                powerIndicator.style.display = 'block';
                const powerBar = powerIndicator.querySelector('.power-bar');
                if (powerBar) {
                    powerBar.style.width = `${progress * 100}%`;
                }
            }
            
            // Animation visuelle de chargement - compression puis extension
            if (progress < 0.5) {
                // Phase de compression
                const scale = 1 - (progress * 0.25);
                samoussa.style.transform = `scale(${scale}, ${1 + progress * 0.25})`;
            } else {
                // Phase de préparation avec effet de pulsation
                const bounce = Math.sin((progress - 0.5) * 6 * Math.PI) * 0.05;
                samoussa.style.transform = `scale(${0.85 + bounce}, ${1.15 - bounce})`;
            }
            
            // Continuer l'animation tant que la touche/écran est pressée
            if (isSpacePressed || isTouching) {
                requestAnimationFrame(startJumpCharge);
            } else {
                // Cacher l'indicateur quand on relâche
                if (powerIndicator) {
                    powerIndicator.style.display = 'none';
                }
            }
        }

        function jump() {
    if (isJumping || isGameOver) return;
    
    // Réinitialiser en cas de problème (une seule fois)
    if (jumpAnimationId) {
        cancelAnimationFrame(jumpAnimationId);
        jumpAnimationId = null;
    }
    
    // Initialiser les variables de saut (une seule fois)
    isJumping = true;
    jumpTime = 0;
    lastJumpTime = 0;
    
    // Position initiale du samoussa
    const initialBottom = parseInt(window.getComputedStyle(samoussa).getPropertyValue('bottom'));
    
    // Jouer le son de saut à ce moment précis
    AudioManager.playSound('jump');
    
    // Éliminer toute transition précédente
    samoussa.style.transition = "";
    
    // Appliquer la puissance du saut aux paramètres
    const actualJumpHeight = jumpHeight * jumpPower;
            
            // Système de rafraîchissement adaptatif
            let previousProgress = 0;
            
            function updateJump(timestamp) {
                if (isGameOver) {
                    isJumping = false;
                    jumpAnimationId = null;
                    return;
                }
                
                if (!lastJumpTime) lastJumpTime = timestamp;
                const deltaTime = timestamp - lastJumpTime;
                
                // Contrôle plus fin pour animations rapides
                if (deltaTime < 8) {
                    jumpAnimationId = requestAnimationFrame(updateJump);
                    return;
                }
                
                jumpTime += deltaTime / 16;
                lastJumpTime = timestamp;
                
                // Animation visuelle de déplacement
                const jumpProgress = Math.min(jumpTime / jumpDuration, 1.0);
                
                // Hauteur de saut parabolique
                const verticalPosition = Math.sin(jumpProgress * Math.PI) * actualJumpHeight + initialBottom;
                
                // Position horizontale fixe
                samoussa.style.bottom = verticalPosition + 'px';
                
                // Illusion de mouvement horizontal par transformation CSS
                let visualOffset = 0;
                if (jumpProgress < 0.5) {
                    // Mouvement visuel vers l'avant jusqu'à 50% du saut
                    visualOffset = jumpProgress * 50;
                } else {
                    // Retour progressif à la position neutre
                    visualOffset = (1 - jumpProgress) * 50;
                }
                
                // Rotation combinée avec translation pour effet de mouvement
                let rotationAngle = 0;
                if (jumpProgress < 0.3) {
                    rotationAngle = 15;
                } else if (jumpProgress < 0.7) {
                    rotationAngle = 0;
                } else {
                    rotationAngle = -10;
                }
                
                // Appliquer la transformation combinée
                samoussa.style.transform = `rotate(${rotationAngle}deg) translateX(${visualOffset}px)`;
                
                // Fin anticipée du saut pour permettre un enchaînement plus rapide
                if (previousProgress > 0.8 && jumpProgress >= 0.98) {
                    finishJump();
                    return;
                }
                
                previousProgress = jumpProgress;
                
                // Continuer le saut jusqu'à la fin
                if (jumpProgress < 1.0) {
                    jumpAnimationId = requestAnimationFrame(updateJump);
                } else {
                    finishJump();
                }
            }
            
            // Fonction séparée pour terminer le saut proprement
            function finishJump() {
                isJumping = false;
                jumpAnimationId = null;
                
                // Retour à la position de repos sans effet visuel
                samoussa.style.bottom = initialSamoussaBottom + 'px';
                samoussa.style.transform = 'rotate(0deg)';
            }
            
            jumpAnimationId = requestAnimationFrame(updateJump);
        }

        // Fonction pour démarrer le jeu
        function startGame() {
    // Vérifier à nouveau si c'est un appareil mobile
    if (!isMobile) {
        console.log("Tentative de démarrage sur desktop bloquée");
        document.getElementById('desktop-message').style.display = 'flex';
        return; // Arrêter l'exécution de la fonction
    }
            
// Assurez-vous que le contexte audio est dans un état correct avant de jouer la musique
    if (AudioManager && AudioManager.context) {
        // S'assurer que le contexte est repris
        if (AudioManager.context.state !== "running") {
            AudioManager.context.resume().then(() => {
                // Ajouter un petit délai avant de jouer la musique
                setTimeout(() => {
                    AudioManager.playMusic('sounds/background.mp3');
                }, 50);
            });
        } else {
            // Ajouter un petit délai avant de jouer la musique
            setTimeout(() => {
                AudioManager.playMusic('sounds/background.mp3');
            }, 50);
        }
    } else {
        // Fallback si le gestionnaire audio n'est pas disponible
        setTimeout(() => {
            if (AudioManager) AudioManager.playMusic('sounds/background.mp3');
        }, 100);
    }
            
             // AJOUTER CETTE LIGNE - Nettoyer les oiseaux existants
    clearAllPaillesEnQueue();
    
            const existingMiniButton = document.getElementById('mini-replay-button');
if (existingMiniButton) {
    existingMiniButton.remove();
}
            console.log("Démarrage du jeu");
            startScreen.style.display = 'none';
            isGameOver = false;
            isGameStarted = true;
            isInvisible = false;
            invisibilityTimer = 0;
            score = 0;
            gameTime = 0;
            
            // Réinitialiser les variables de difficulté
            gameSpeed = isMobile ? 2.7 : 3; // Valeur initiale de gameSpeed
            difficultyLevel = 1; // Valeur initiale de difficultyLevel
            minObstacleDistance = 350; // Valeur initiale de la distance entre obstacles
            
            // Réinitialiser le système de combo
            comboMultiplier = 1;
            comboCount = 0;
            maxCombo = 1;
            document.getElementById('combo-container').style.display = 'none';
            document.getElementById('combo-count').textContent = 'x1';
            
            // Mettre à jour l'affichage
            scoreElement.textContent = score;
            lastObstaclePosition = 0;
            nextObstacleTime = 3000;
            nextCollectibleTime = 2000;
            
            // Masquer le tableau des scores pendant le jeu
            document.getElementById('highscores').style.display = 'none';
            
            // Créer un paille-en-queue initial après le démarrage
setTimeout(() => {
    createPailleEnQueue();
}, 3000); // Attendre 3 secondes pour qu'il apparaisse après le début du jeu
            
            // Mettre à jour l'affichage du saut
        if (isMobile) {
            jumpHint.innerHTML = 'Tapez pour sauter !<br><span style="color: #FFD700; font-size: 0.9em; margin-top: 5px; display: inline-block;">Appuyez longtemps pour sauter plus haut</span>';
            jumpHint.style.display = 'block';
            // Le cacher après un délai plus long
            setTimeout(() => {
                jumpHint.style.display = 'none';
            }, 5000);
        }
            
            // Réinitialiser la position du samoussa
            samoussa.style.bottom = initialSamoussaBottom + 'px';
            samoussa.style.transform = 'rotate(0deg)';
            samoussa.style.backgroundImage = `url(${samoussaImages.run1})`;
            samoussa.classList.remove('invisible');
            invisibilityEffect.style.display = 'none';
            
            // Activer l'animation des nuages
            document.querySelectorAll('.cloud').forEach(cloud => {
                cloud.style.animationPlayState = 'running';
            });
            
            // Lancer ou relancer le générateur de nuages
            if (!cloudGeneratorInterval) {
                cloudGeneratorInterval = startCloudGenerator();
            }
            
            // Supprimer tous les obstacles et collectibles existants
            clearElements();
            
            // Intervalles pour le jeu
const gameInterval = setInterval(() => {
    // Mettre à jour le temps de jeu
    gameTime += 100;
    
    // Générer les obstacles
    if (gameTime >= nextObstacleTime) {
        // Vérifier s'il est trop tôt pour générer de nouveaux obstacles doubles
        const tooSoonForDoubleObstacle = (gameTime - lastDoubleObstacleTime < doubleObstacleRestPeriod);
        
        // Si des obstacles doubles ont été générés récemment et niveau <= 6, forcer un obstacle simple
        if (difficultyLevel <= 6 && tooSoonForDoubleObstacle) {
            // Sauvegarder la valeur originale de createDouble
            const originalCreateDouble = Math.random() < 0.25 && difficultyLevel >= 4;
            
            // Temporairement forcer les obstacles simples
            const createDoubleBackup = window.createDoubleOverride;
            window.createDoubleOverride = true;
            
            // Appel à createObstacle avec override
            createObstacle();
            
            // Restaurer l'état
            window.createDoubleOverride = createDoubleBackup;
        } else {
            // Comportement normal
            createObstacle();
        }
        
        // Prochain obstacle avec délai variable basé sur la difficulté
        let minDelay = Math.max(1000, 1800 - ((difficultyLevel - 1) * 100));
        let maxAdditionalDelay = Math.max(500, 1500 - ((difficultyLevel - 1) * 150));
        
        // Si nous venons de générer un obstacle double, augmenter le délai pour la prochaine génération
        if (gameTime - lastDoubleObstacleTime < 1000) {
            // Ajouter un délai supplémentaire après des obstacles doubles
            minDelay += 800;
            maxAdditionalDelay += 500;
        }
        
        nextObstacleTime = gameTime + minDelay + Math.random() * maxAdditionalDelay;
    }
    
    // Générer les collectibles
    if (gameTime >= nextCollectibleTime) {
        createSafeCollectible();
        // Prochain collectible avec délai variable
        const minDelay = 3000;
        const maxAdditionalDelay = 2000;
        nextCollectibleTime = gameTime + minDelay + Math.random() * maxAdditionalDelay;
    }
    
    // Vérifier si le combo doit être réinitialisé (temps écoulé depuis la dernière collecte)
    if (comboCount > 0 && Date.now() - lastCollectTime > comboDuration) {
        resetCombo();
    }
}, 100);

// Intervalles pour l'animation et le score
const scoreInterval = setInterval(updateScore, 100);
const animationInterval = setInterval(animateSamoussa, 200);
const effectsInterval = setInterval(updateEffects, 1000);

// Stocker les intervalles pour pouvoir les arrêter plus tard
window.gameIntervals = {
    game: gameInterval,
    score: scoreInterval,
    animation: animationInterval,
    effects: effectsInterval
};

// Réinitialiser le timer pour l'animation
lastFrameTime = 0;

// Démarrer l'animation du jeu
requestAnimationFrame(updateGame);
        }

        // Fonction pour redémarrer le jeu
        function restartGame() {
            gameOverScreen.style.display = 'none';
            
            // Réinitialiser les variables
            isJumping = false;
            isSpacePressed = false;
            isTouching = false;
            jumpTime = 0;
            
            // Redémarrer le jeu après une courte pause
            setTimeout(() => {
                startGame();
            }, 100);
        }

        // Nettoyer les éléments existants
        function clearElements() {
            obstacles.forEach(obstacle => {
                if (obstacle.element && obstacle.element.parentNode) {
                    obstacle.element.remove();
                }
            });
            collectibles.forEach(collectible => {
                if (collectible.element && collectible.element.parentNode) {
                    collectible.element.remove();
                }
            });
            obstacles = [];
            collectibles = [];
        }

        // Animer le samoussa
        function animateSamoussa() {
            if (isGameOver || isJumping) return;
            
            currentFrame = (currentFrame + 1) % 2;
            
            // Alterner entre les deux images de course
            if (!document.body.classList.contains('fallback-mode')) {
                if (currentFrame === 0) {
                    samoussa.style.backgroundImage = `url(${samoussaImages.run1})`;
                } else {
                    samoussa.style.backgroundImage = `url(${samoussaImages.run2})`;
                }
            }
        }
function calculateJumpableDistance() {
    // Distance couverte pendant la durée d'un saut à vitesse actuelle
    const jumpTimeFrames = jumpDuration;
    const distancePerFrame = gameSpeed;
    
    // Distance max franchissable avec un saut à pleine puissance
    const maxJumpDistance = jumpTimeFrames * distancePerFrame;
    
    // Temps nécessaire pour retomber et pouvoir ressauter (frames)
    // Adaptation intelligente selon la vitesse du jeu - plus de marge quand c'est rapide
    const baseRecoveryFrames = 30;
    const speedFactor = Math.min(1.5, Math.max(1, gameSpeed / 4)); // 1 à 1.5x selon la vitesse
    const recoveryFrames = Math.ceil(baseRecoveryFrames * speedFactor);
    
    // Distance minimale nécessaire entre deux obstacles pour permettre deux sauts
    const minDoubleJumpDistance = maxJumpDistance + (recoveryFrames * distancePerFrame);
    
    // Distance maximale franchissable en un seul saut avec une marge de sécurité
    // Réduite pour être sûr que c'est faisable
    const safeMaxSingleJump = maxJumpDistance * 0.8;
    
    console.log(`[DEBUG] gameSpeed: ${gameSpeed}, recoveryFrames: ${recoveryFrames}`);
    console.log(`[DEBUG] maxJump: ${maxJumpDistance}, doubleJumpDist: ${minDoubleJumpDistance}`);
    
    return {
        maxSingleJump: safeMaxSingleJump,
        minDoubleJumpDistance: minDoubleJumpDistance,
        // Distance idéale pour un saut double (avec marge de confort)
        idealDoubleJumpDistance: minDoubleJumpDistance * 1.3, // Augmenté de 1.2 à 1.3
        // Distance idéale pour un saut simple (ni trop proche ni trop loin)
        idealSingleJumpDistance: safeMaxSingleJump * 0.7
    };
}
// Fonction pour créer un obstacle
function createObstacle() {
    if (isGameOver) return;
    
    // Vérifier la distance avec le dernier obstacle
    const rightmostObstacle = obstacles.reduce((maxPos, obstacle) => 
        Math.max(maxPos, obstacle.position), 0);
    
    const adjustedDistance = minObstacleDistance * (gameContainerWidth / 800);
    
    if (rightmostObstacle > gameContainerWidth - adjustedDistance) {
        return;
    }
    
    // À des niveaux plus élevés, possibilité d'obstacles doubles
    let createDouble = false;
    if (difficultyLevel >= 4 && Math.random() < 0.25) {
        createDouble = true;
    }
    
    // Créer le premier obstacle
    const obstacle = document.createElement('div');
    obstacle.classList.add('obstacle');
    
    // Type d'obstacle aléatoire
    const obstacleType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
    obstacle.classList.add(obstacleType);
    
    // Position initiale à droite de l'écran
    obstacle.style.left = gameContainerWidth + 'px';
    obstacle.style.bottom = initialSamoussaBottom + 'px';
    gameContainer.appendChild(obstacle);
    
    obstacles.push({
        element: obstacle,
        position: gameContainerWidth,
        type: obstacleType
    });
    
    lastObstaclePosition = gameContainerWidth;
    
    // Créer un deuxième obstacle si nécessaire
    if (createDouble && difficultyLevel >= 4) {
        // Mémoriser que nous venons de créer un obstacle double
        lastDoubleObstacleTime = gameTime;
        
        setTimeout(() => {
            if (isGameOver) return;
            
            const obstacle2 = document.createElement('div');
            obstacle2.classList.add('obstacle');
            
            // Type différent pour le second obstacle
            let obstacleType2;
            do {
                obstacleType2 = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
            } while (obstacleType2 === obstacleType && obstacleTypes.length > 1);
            
            obstacle2.classList.add(obstacleType2);
            
                // Facteur d'échelle basé sur la taille de l'écran
            const spacingFactor = gameContainerWidth / 800;
            
            // Calculer les distances de saut possibles avec la vitesse actuelle
            const jumpability = calculateJumpableDistance();
            
            // Variable pour stocker la stratégie et l'espacement
            let jumpStrategy;
            let spacing;
            
            // Pour forcer l'apparition du saut long parfois, indépendamment du niveau
            const forceLongJump = Math.random() < 0.3; // 30% de chance de forcer un saut long
            
            // Déterminer la stratégie selon le niveau et le hasard
            if ((difficultyLevel <= 5 && !forceLongJump) || (difficultyLevel <= 3)) {
                // Niveaux 4-5: GÉNÉRALEMENT configurer pour double saut avec une grande marge de sécurité
                jumpStrategy = 'double';
                
                // Traitement spécial pour le niveau 5 qui est un peu plus difficile
if (difficultyLevel === 5) {
   
    spacing = jumpability.idealDoubleJumpDistance * 1.9 * spacingFactor;
} else {
    // Espacement très généreux pour les autres niveaux
    spacing = jumpability.idealDoubleJumpDistance * 1.45 * spacingFactor;
}
            }
            else if (difficultyLevel <= 7) {
                // Niveaux 6-7: Mélange plus équilibré
                if (Math.random() < 0.4 || forceLongJump) {
                    // 40% de chance d'avoir un saut simple (ou forcé)
                    jumpStrategy = 'single';
                    // Distance NETTEMENT plus courte pour être franchie en un seul saut
                    spacing = jumpability.idealSingleJumpDistance * 0.8 * spacingFactor;
                } else {
                    // 60% de chance d'avoir un double saut
                    jumpStrategy = 'double';
                    // Espacement très confortable aux niveaux intermédiaires
                    spacing = jumpability.idealDoubleJumpDistance * 2 * spacingFactor;
                }
            }
            else {
                // Niveaux 8+: Préférence pour les sauts simples
                if (Math.random() < 0.6 || forceLongJump) {
                    // 60% de chance d'avoir un saut simple (ou forcé)
                    jumpStrategy = 'single';
                    // Distance courte mais franchissable en un saut
                    spacing = jumpability.idealSingleJumpDistance * spacingFactor;
                } else {
                    // 40% de chance d'avoir un double saut
                    jumpStrategy = 'double';
                    // Espacement difficile mais faisable avec un timing précis
                    spacing = jumpability.idealDoubleJumpDistance * 1.95 * spacingFactor;
                }
            }
            
            // Ajustement final pour éviter des espacements trop extrêmes
            if (jumpStrategy === 'single') {
                // Pour la stratégie de saut unique, s'assurer que c'est VRAIMENT court
                spacing = Math.min(spacing, jumpability.maxSingleJump * 0.7 * spacingFactor);
                // Minimum absolu pour éviter des obstacles qui se chevauchent
                spacing = Math.max(spacing, 150 * spacingFactor);
            } else {
                // Pour la stratégie de double saut, s'assurer qu'il y a assez d'espace
                spacing = Math.max(spacing, jumpability.minDoubleJumpDistance * 1.1 * spacingFactor);
                // Maximum absolu pour la santé mentale
                spacing = Math.min(spacing, 550 * spacingFactor);
            }
            
            // Afficher l'indice visuel de stratégie BEAUCOUP plus tôt
            if (difficultyLevel >= 4) {
                // Position qui précède les obstacles - différenciée selon le type de saut
let hintPosition;
if (jumpStrategy === 'single') {
    // Afficher beaucoup plus tôt l'indice pour le saut long
    hintPosition = gameContainerWidth * 0.95;  // Presque à l'extrême droite de l'écran
} else {
    // Position standard pour le double saut
    hintPosition = gameContainerWidth * 0.85;
}

// Durée adaptée selon la stratégie - plus longue pour le saut long
let hintDuration;
if (jumpStrategy === 'single') {
    // Durée plus longue pour le saut long qui nécessite plus de préparation
    hintDuration = Math.max(2200, 2800 - ((difficultyLevel - 4) * 100));  // Augmentée
} else {
    // Durée standard pour le double saut
    hintDuration = Math.max(1200, 2000 - ((difficultyLevel - 4) * 100));
}
                
                // Toujours montrer les indices
                showJumpHint(hintPosition, jumpStrategy, hintDuration, spacing);
            }
            obstacle2.style.bottom = initialSamoussaBottom + 'px';
            gameContainer.appendChild(obstacle2);
            
            obstacles.push({
                element: obstacle2,
                position: gameContainerWidth + spacing,
                type: obstacleType2
            });
            
            lastObstaclePosition = gameContainerWidth + spacing;
        }, 100);
    }
}

        // Fonction pour créer un collectible accessible et sans collision avec les obstacles
        function createSafeCollectible() {
            if (isGameOver) return;
            
            const collectible = document.createElement('div');
            collectible.classList.add('collectible');
            
            // Type de collectible aléatoire
            const collectibleType = collectibleTypes[Math.floor(Math.random() * collectibleTypes.length)];
            collectible.classList.add(collectibleType);
            
            // Position toujours à droite de l'écran
            let positionX = gameContainerWidth;
            collectible.style.left = positionX + 'px';
            
            // Récupérer tous les obstacles existants pour vérifier les collisions
            const allObstacles = obstacles.map(o => ({
                x: o.position,
                y: parseInt(o.element.style.bottom) || initialSamoussaBottom,
                width: parseInt(window.getComputedStyle(o.element).width),
                height: parseInt(window.getComputedStyle(o.element).height)
            }));
            
            // Tentatives de placement sans collision
            let attempts = 0;
            let validPosition = false;
            let positionY = 0;
            
            while (!validPosition && attempts < 20) {
                attempts++;
                
                // Déterminer une position verticale de base
                const gameHeight = gameContainer.clientHeight;
                if (Math.random() < 0.7) {
                    // 70% du temps en hauteur
                    positionY = Math.random() * (gameHeight * 0.3) + (initialSamoussaBottom + 30);
                } else {
                    // 30% du temps près du sol
                    positionY = Math.random() * 30 + (initialSamoussaBottom + 10);
                }
                
                // Vérifier la distance avec tous les obstacles
                let tooClose = false;
                
                for (const obstacle of allObstacles) {
                    // Distance horizontale
                    const horizontalDistance = Math.abs(positionX - obstacle.x);
                    
                    // Distance verticale
                    const collectibleHeight = (collectibleType === 'biere') ? 60 : 50;
                    const verticalOverlap = (positionY < obstacle.y + obstacle.height) && 
                                           (positionY + collectibleHeight > obstacle.y);
                    
                    // Si trop proche horizontalement et en chevauchement vertical
                    if (horizontalDistance < 100 && verticalOverlap) {
                        tooClose = true;
                        break;
                    }
                }
                
                // Si position valide (pas trop proche d'obstacles)
                if (!tooClose) {
                    validPosition = true;
                } else {
                    // Ajuster la position X pour éviter les obstacles
                    positionX += 50 + Math.random() * 50;
                }
            }
            
            // Si après 20 tentatives toujours pas de position valide, placer loin
            if (!validPosition) {
                positionX = gameContainerWidth + 200 + Math.random() * 200;
                positionY = Math.random() * (gameContainer.clientHeight * 0.3) + (initialSamoussaBottom + 30);
            }
            
            // Appliquer les positions
            collectible.style.left = positionX + 'px';
            collectible.style.bottom = positionY + 'px';
            
            gameContainer.appendChild(collectible);
            
            collectibles.push({
                element: collectible,
                position: positionX,
                bottom: positionY,
                type: collectibleType
            });
        }

// Fonction pour vérifier les collisions avec des hitboxes précises
        function checkCollision(element1, element2) {
            // Version améliorée qui utilise les pseudoéléments ::after comme hitbox
            const rect1 = element1.getBoundingClientRect();
            const rect2 = element2.getBoundingClientRect();
            
            // Taille relative de la hitbox par rapport à l'élément parent
            // Ces valeurs correspondent aux pourcentages dans le CSS
            const hitbox1 = {
                width: rect1.width * 0.7, 
                height: rect1.height * 0.7,
                left: rect1.left + rect1.width * 0.15,
                top: rect1.top + rect1.height * 0.15
            };
            
            // Déterminer la taille de hitbox en fonction du type d'élément
            let hitbox2;
            if (element2.classList.contains('couteau')) {
                hitbox2 = {
                    width: rect2.width * 0.6,
                    height: rect2.height * 0.7,
                    left: rect2.left + rect2.width * 0.2,
                    top: rect2.top + rect2.height * 0.15
                };
            } else if (element2.classList.contains('marmite')) {
                hitbox2 = {
                    width: rect2.width * 0.7,
                    height: rect2.height * 0.8,
                    left: rect2.left + rect2.width * 0.15,
                    top: rect2.top + rect2.height * 0.15
                };
            } else if (element2.classList.contains('main')) {
                hitbox2 = {
                    width: rect2.width * 0.7,
                    height: rect2.height * 0.9,
                    left: rect2.left + rect2.width * 0.15,
                    top: rect2.top + rect2.height * 0.05
                };
            } else if (element2.classList.contains('collectible')) {
                hitbox2 = {
                    width: rect2.width * 0.7,
                    height: rect2.height * 0.7,
                    left: rect2.left + rect2.width * 0.15,
                    top: rect2.top + rect2.height * 0.15
                };
            } else {
                // Hitbox par défaut
                hitbox2 = {
                    width: rect2.width,
                    height: rect2.height,
                    left: rect2.left,
                    top: rect2.top
                };
            }
            
            // Vérifier si les hitboxes se chevauchent
            return !(
                hitbox1.left + hitbox1.width < hitbox2.left ||
                hitbox1.left > hitbox2.left + hitbox2.width ||
                hitbox1.top + hitbox1.height < hitbox2.top ||
                hitbox1.top > hitbox2.top + hitbox2.height
            );
        }

        // Mettre à jour le score et la difficulté
        function updateScore() {
            if (isGameOver) return;
            
            score += 1;
            scoreElement.textContent = score;
            
            // Paliers de difficulté
            const difficultyThresholds = [
                { score: 300, speed: isMobile ? 3.2 : 3.5, distance: 330, level: 2 },
                { score: 600, speed: isMobile ? 3.7 : 4.0, distance: 300, level: 3 },
                { score: 1000, speed: isMobile ? 4.2 : 4.5, distance: 280, level: 4 },
                { score: 1500, speed: isMobile ? 4.7 : 5.0, distance: 260, level: 5 },
                { score: 2000, speed: isMobile ? 5.2 : 5.5, distance: 240, level: 6 },
                { score: 2500, speed: isMobile ? 5.7 : 6.0, distance: 220, level: 7 },
                { score: 3000, speed: isMobile ? 6.2 : 6.5, distance: 200, level: 8 },
                { score: 4000, speed: isMobile ? 6.7 : 7.0, distance: 180, level: 9 }
            ];
            
            // Augmenter la difficulté selon le score
            for (const threshold of difficultyThresholds) {
                if (score >= threshold.score && difficultyLevel < threshold.level) {
                    gameSpeed = threshold.speed;
                    minObstacleDistance = threshold.distance;
                    difficultyLevel = threshold.level;
                    
                    // AJOUTEZ ICI - Son de niveau supérieur
        AudioManager.playSound('levelUp');
                    
                    // Notification de changement de niveau
                    const levelUpNotice = document.createElement('div');
                    levelUpNotice.style.position = 'absolute';
                    levelUpNotice.style.top = '50%';
                    levelUpNotice.style.left = '50%';
                    levelUpNotice.style.transform = 'translate(-50%, -50%)';
                    levelUpNotice.style.color = '#FF5722';
                    levelUpNotice.style.fontWeight = 'bold';
                    levelUpNotice.style.fontSize = '28px';
                    levelUpNotice.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
                    levelUpNotice.style.zIndex = '50';
                    levelUpNotice.textContent = `Niveau ${threshold.level}!`;
                    
                    gameContainer.appendChild(levelUpNotice);
                    
                    // Animation de fondu
                    let opacity = 1;
                    const fadeOut = setInterval(() => {
                        opacity -= 0.05;
                        levelUpNotice.style.opacity = opacity;
                        
                        if (opacity <= 0) {
                            clearInterval(fadeOut);
                            if (levelUpNotice.parentNode) {
                                levelUpNotice.remove();
                            }
                        }
                    }, 50);
                    
                    break;
                }
            }
        }

        // Mettre à jour les effets actifs
        function updateEffects() {
            if (isGameOver) return;
            
            // Gestion de l'invisibilité
            if (isInvisible) {
                invisibilityTimer--;
                invisibilityTime.textContent = invisibilityTimer;
                
                if (invisibilityTimer <= 0) {
                    isInvisible = false;
                    samoussa.classList.remove('invisible');
                    invisibilityEffect.style.display = 'none';
                }
            }
        }

        // Activer l'effet d'invisibilité
        function activateInvisibility() {
            isInvisible = true;
            invisibilityTimer = invisibilityDuration;
            invisibilityTime.textContent = invisibilityTimer;
            samoussa.classList.add('invisible');
            invisibilityEffect.style.display = 'block';
        }

        // Effet boost amélioré quand on prend la bière
        function showBoostEffect() {
            // Positionner l'effet sous le samoussa
            const samoussaRect = samoussa.getBoundingClientRect();
            const centerX = samoussaRect.left + (samoussaRect.width / 2);
            
            boostEffect.style.display = 'block';
            boostEffect.style.left = centerX + 'px';
            boostEffect.style.bottom = samoussa.style.bottom;
            
            // Arrêter toute animation précédente
            if (window.boostAnimation) {
                clearTimeout(window.boostAnimation);
            }
            
            // Garder l'effet visible pendant 1 seconde
            window.boostAnimation = setTimeout(() => {
                boostEffect.style.display = 'none';
            }, 1000);
        }

        // Mettre à jour le jeu à chaque frame
        function updateGame(timestamp) {
            if (isGameOver) return;
            
            // Gestion du temps entre les frames
            if (!lastFrameTime) lastFrameTime = timestamp;
            const deltaTime = timestamp - lastFrameTime;
            
            // Limiter la fréquence pour une vitesse constante
            if (deltaTime < frameInterval) {
                requestAnimationFrame(updateGame);
                return;
            }
            
            // Facteur de mouvement basé sur le temps écoulé
            const speedFactor = deltaTime / frameInterval;
            const moveAmount = gameSpeed * speedFactor;
            
            lastFrameTime = timestamp;
            
            // Déplacer les obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position -= moveAmount;
                obstacle.element.style.left = obstacle.position + 'px';
                
                // Supprimer les obstacles hors écran
                if (obstacle.position < -60) {
                    obstacle.element.remove();
                    obstacles.splice(i, 1);
                    continue;
                }
                
                // Vérifier les collisions si pas invisible
                if (!isInvisible) {
                    if (checkCollision(samoussa, obstacle.element)) {
                        gameOver();
                        return;
                    }
                }
            }
            
            // Déplacer les collectibles
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                collectible.position -= moveAmount;
                collectible.element.style.left = collectible.position + 'px';
                
                // Supprimer les collectibles hors écran
                if (collectible.position < -50) {
                    collectible.element.remove();
                    collectibles.splice(i, 1);
                    continue;
                }
                
                // Vérifier les collisions
                if (checkCollision(samoussa, collectible.element)) {
                    // Incrémenter le combo
                    incrementCombo();
                    lastCollectTime = Date.now();
                    
                    // AJOUTEZ ICI - Son de collecte
    if (collectible.type === 'biere') {
        AudioManager.playSound('powerup');
    } else {
        AudioManager.playSound('collect');
    }
                    
                    // Points de base selon le type
                    let basePoints = 10;
                    
                    // Effet selon le type de collectible
                    if (collectible.type === 'biere') {
                        activateInvisibility();
                        basePoints = 20;
                        showBoostEffect();
                        
                        // Vibration sur mobile si supporté
                        if (isMobile && navigator.vibrate) {
                            navigator.vibrate(100);
                        }
                    } else if (collectible.type === 'piment') {
                        basePoints = 15;
                    }
                    
                    // Appliquer le multiplicateur de combo
                    const pointsGained = basePoints * comboMultiplier;
                    score += pointsGained;
                    
                    scoreElement.textContent = score;
                    collectible.element.remove();
                    collectibles.splice(i, 1);
                    
                    // Animation de collecte améliorée
                    const collectEffect = document.createElement('div');
                    collectEffect.className = 'collect-effect';
                    collectEffect.style.left = collectible.position + 'px';
                    collectEffect.style.bottom = collectible.bottom + 'px';
                    
                    // Message selon le type et combo
                    if (collectible.type === 'biere') {
                        collectEffect.textContent = `+${pointsGained} INVISIBLE!`;
                        collectEffect.style.color = '#FF9800';
                    } else if (collectible.type === 'piment') {
                        collectEffect.textContent = `+${pointsGained}`;
                        collectEffect.style.color = '#F44336';
                    } else {
                        collectEffect.textContent = `+${pointsGained}`;
                    }
                    
                    // Faire grossir l'effet en fonction du combo
                    if (comboMultiplier > 1) {
                        collectEffect.style.fontSize = (4 + (comboMultiplier * 0.5)) + 'vmin';
                    }
                    
                    gameContainer.appendChild(collectEffect);
                    
                    // Animation de flottement et disparition
                    setTimeout(() => {
                        collectEffect.style.transform = 'translateY(-50px)';
                        collectEffect.style.opacity = '0';
                    }, 50);
                    
                    setTimeout(() => {
                        if (collectEffect.parentNode) {
                            collectEffect.remove();
                        }
                    }, 1000);
                }
            }
            
            requestAnimationFrame(updateGame);
        }
        
        // Nouvelle fonction de boucle de jeu unifiée
function gameLoop(timestamp) {
    if (isGameOver) return;
    
    if (!lastFrameTime) lastFrameTime = timestamp;
    const deltaTime = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    
    // Mise à jour des obstacles (environ chaque 100ms)
    if (timestamp - lastObstacleCheckTime > 100) {
        // Mettre à jour le temps de jeu
        gameTime += timestamp - lastObstacleCheckTime;
        
        // Générer les obstacles
        if (gameTime >= nextObstacleTime) {
            // Vérifier s'il est trop tôt pour générer de nouveaux obstacles doubles
            const tooSoonForDoubleObstacle = (gameTime - lastDoubleObstacleTime < doubleObstacleRestPeriod);
            
            // Si des obstacles doubles ont été générés récemment et niveau <= 6, forcer un obstacle simple
            if (difficultyLevel <= 6 && tooSoonForDoubleObstacle) {
                // Sauvegarder la valeur originale de createDouble
                const originalCreateDouble = Math.random() < 0.25 && difficultyLevel >= 4;
                
                // Temporairement forcer les obstacles simples
                const createDoubleBackup = window.createDoubleOverride;
                window.createDoubleOverride = true;
                
                // Appel à createObstacle avec override
                createObstacle();
                
                // Restaurer l'état
                window.createDoubleOverride = createDoubleBackup;
            } else {
                // Comportement normal
                createObstacle();
            }
            
            // Prochain obstacle avec délai variable basé sur la difficulté
            let minDelay = Math.max(1000, 1800 - ((difficultyLevel - 1) * 100));
            let maxAdditionalDelay = Math.max(500, 1500 - ((difficultyLevel - 1) * 150));
            
            // Si nous venons de générer un obstacle double, augmenter le délai pour la prochaine génération
            if (gameTime - lastDoubleObstacleTime < 1000) {
                // Ajouter un délai supplémentaire après des obstacles doubles
                minDelay += 800;
                maxAdditionalDelay += 500;
            }
            
            nextObstacleTime = gameTime + minDelay + Math.random() * maxAdditionalDelay;
        }
        
        // Générer les collectibles
        if (gameTime >= nextCollectibleTime) {
            createSafeCollectible();
            // Prochain collectible avec délai variable
            const minDelay = 3000;
            const maxAdditionalDelay = 2000;
            nextCollectibleTime = gameTime + minDelay + Math.random() * maxAdditionalDelay;
        }
        
        // Vérifier si le combo doit être réinitialisé (temps écoulé depuis la dernière collecte)
        if (comboCount > 0 && Date.now() - lastCollectTime > comboDuration) {
            resetCombo();
        }
        
        lastObstacleCheckTime = timestamp;
    }
    
    // Mise à jour du score (environ chaque 100ms)
    if (timestamp - lastScoreUpdateTime > 100) {
        updateScore();
        lastScoreUpdateTime = timestamp;
    }
    
    // Mise à jour des effets (environ chaque seconde)
    if (timestamp - lastEffectsUpdateTime > 1000) {
        updateEffects();
        lastEffectsUpdateTime = timestamp;
    }
    
    // Animation du samoussa (environ chaque 200ms)
    if (timestamp - lastAnimationUpdateTime > 200) {
        animateSamoussa();
        lastAnimationUpdateTime = timestamp;
    }
    
    // Mise à jour du jeu
    updateGame(timestamp);
    
    // Continuer la boucle
    requestAnimationFrame(gameLoop);
}

       function gameOver() {
    isGameOver = true;
    isJumping = false;
    isSpacePressed = false;
    isTouching = false;
           
            // AJOUTEZ ICI - Son de crash
    AudioManager.playSound('crash');
    
    // Cacher l'indicateur de puissance
    if (powerIndicator) {
        powerIndicator.style.display = 'none';
    }
    
    // Cacher l'indice de saut
    jumpHint.style.display = 'none';
    
    // Masquer le conteneur de combo
    document.getElementById('combo-container').style.display = 'none';
    
    // Mettre à jour et afficher le tableau des meilleurs scores
    updateHighScores();
    document.getElementById('highscores').style.display = 'none'; // Masquer le tableau isolé
           // Ajouter un paille-en-queue initial

    // Annuler l'animation de saut
    if (jumpAnimationId) {
        cancelAnimationFrame(jumpAnimationId);
        jumpAnimationId = null;
    }
    
   // Arrêter tous les intervalles
if (window.gameIntervals) {
    Object.values(window.gameIntervals).forEach(interval => {
        clearInterval(interval);
    });
    // AJOUTER CE CODE ICI
    if (window.gameIntervals.pailleEnQueue) {
        clearInterval(window.gameIntervals.pailleEnQueue);
    }
}
    
    // Arrêter le générateur de nuages
    if (cloudGeneratorInterval) {
        clearInterval(cloudGeneratorInterval);
        cloudGeneratorInterval = null;
    }
    
    // Animation de crash
    if (!document.body.classList.contains('fallback-mode')) {
        samoussa.style.backgroundImage = `url(${samoussaImages.crash})`;
    }
    samoussa.style.transform = 'rotate(45deg)';
    
    // Vibration sur mobile si supporté
    if (isMobile && navigator.vibrate) {
        navigator.vibrate([100, 50, 200]);
    }
    
    // Mettre à jour les scores finaux
    finalScoreElement.textContent = score;
    document.getElementById('final-combo').textContent = `x${maxCombo}`;
    document.getElementById('final-level').textContent = difficultyLevel;
           
           // Masquer le conteneur de combo si le combo n'est pas significatif
if (maxCombo <= 1) {
    document.getElementById('final-combo-container').style.display = 'none';
} else {
    document.getElementById('final-combo-container').style.display = 'block';
}

// Ajuster dynamiquement la taille du texte si le score est très grand
const finalScore = document.getElementById('final-score');
if (score > 9999) {
    finalScore.style.fontSize = '0.9em';
}

// Adaptation pour les grands écrans (comme iPhone 15)
const screenHeight = window.innerHeight;
const gameOverScreen = document.getElementById('game-over');
if (screenHeight > 800) {
    gameOverScreen.classList.add('large-screen');
} else {
    gameOverScreen.classList.remove('large-screen');
}
    
    // Générer un QR code si niveau suffisant (5+)
    // Supprimer l'ancienne section de récompense si elle existe
    const oldRewardSection = gameOverScreen.querySelector('.reward-section');
    if (oldRewardSection) {
        oldRewardSection.remove();
    }
    
    if (difficultyLevel >= 5) {
    const qrResult = generateRewardQR(score, difficultyLevel);
    
    if (qrResult) {
        // Créer la section récompense
        const rewardSection = document.createElement('div');
        rewardSection.className = 'reward-section';
        
        // AJOUTER CE BLOC DE CODE CONDITIONNEL ICI
        if (qrResult.isLimited) {
            // Afficher un message de limite au lieu du QR
            if (qrResult.isPermanent) {
                // Message pour limitation permanente (niveau 9)
                rewardSection.innerHTML = `
                    <h3 class="reward-title">RÉCOMPENSE DÉJÀ OBTENUE</h3>
                    <p class="reward-text">${qrResult.message}</p>
                    <p class="reward-text">Cette récompense ne peut être gagnée qu'une seule fois.</p>
                `;
            } else {
                // Message pour limitation mensuelle (autres niveaux)
                rewardSection.innerHTML = `
                    <h3 class="reward-title">LIMITE ATTEINTE</h3>
                    <p class="reward-text">${qrResult.message}</p>
                    <p class="reward-text">Réessayez dans ${qrResult.remainingDays} jours.</p>
                `;
            }
        } else {
            // CONSERVER CE BLOC EXISTANT POUR L'AFFICHAGE NORMAL
            rewardSection.innerHTML = `
                <h3 class="reward-title">FÉLICITATIONS!</h3>
                <p class="reward-text">Vous avez gagné:</p>
                <p class="reward-text"><strong>${qrResult.reward}</strong></p>
                <div class="qr-container">${qrResult.html}</div>
                <p class="code-text">Code: ${qrResult.code}</p>
                <p class="expiry">Valable jusqu'au ${qrResult.expiryDate}</p>
                <p class="screenshot-hint">📱 Faites une capture d'écran de ce QR code ! 📱</p>
            `;
        }
        // FIN DU BLOC CONDITIONNEL
            
        // CONSERVER TOUT CE CODE EXISTANT TEL QUEL
        // Ajouter le tableau des meilleurs scores dans la section récompense
        const highScoresElement = document.createElement('div');
        highScoresElement.innerHTML = `
            <h4 style="color: #FFD700; margin-top: 15px; margin-bottom: 5px;">Meilleurs scores:</h4>
            <ol style="text-align: left; padding-left: 25px; margin-top: 5px;">
                ${highScores.map(score => `<li>${score}</li>`).join('')}
            </ol>
        `;
        rewardSection.appendChild(highScoresElement);
        
        // Ajouter un bouton rejouer directement dans la section récompense
        const replayButtonInReward = document.createElement('button');
        replayButtonInReward.className = 'btn';
        replayButtonInReward.style.fontSize = '4vmin'; // Plus petit
        replayButtonInReward.style.padding = '10px 20px'; // Plus petit
        replayButtonInReward.style.marginTop = '15px';
        replayButtonInReward.textContent = 'REJOUER';
        replayButtonInReward.addEventListener('click', restartGame);
        replayButtonInReward.addEventListener('touchstart', function(event) {
            event.preventDefault();
            restartGame();
        });
        rewardSection.appendChild(replayButtonInReward);
            
        // Insérer avant le bouton de restart
        const restartButton = document.getElementById('restart-button');
        gameOverScreen.insertBefore(rewardSection, restartButton);
    }
    } else {
        // Pour les niveaux inférieurs, afficher seulement les meilleurs scores
        const scoresSection = document.createElement('div');
        scoresSection.className = 'reward-section';
        scoresSection.innerHTML = `
            <h4 style="color: #FFD700; margin-top: 5px; margin-bottom: 10px;">Meilleurs scores:</h4>
            <ol style="text-align: left; padding-left: 25px; margin-top: 5px;">
                ${highScores.map(score => `<li>${score}</li>`).join('')}
            </ol>
            <p class="reward-text" style="margin-top: 15px;">Atteignez le niveau 5 pour gagner une récompense!</p>
        `;
        
        // Insérer avant le bouton de restart
        const restartButton = document.getElementById('restart-button');
        gameOverScreen.insertBefore(scoresSection, restartButton);
    }
    
    setTimeout(() => {
        gameOverScreen.style.display = 'flex';
    }, 500);
           setTimeout(() => {
    // Si le niveau 5+ est atteint et QR code affiché, ajouter un petit bouton rejeu flottant
    if (difficultyLevel >= 5) {
        const miniReplayButton = document.createElement('div');
        miniReplayButton.id = 'mini-replay-button';
        miniReplayButton.style.position = 'fixed';
        miniReplayButton.style.bottom = '20px';
        miniReplayButton.style.right = '20px';
        miniReplayButton.style.width = '50px';
        miniReplayButton.style.height = '50px';
        miniReplayButton.style.borderRadius = '50%';
        miniReplayButton.style.backgroundColor = '#ff6b6b';
        miniReplayButton.style.boxShadow = '0 3px 8px rgba(0,0,0,0.3)';
        miniReplayButton.style.display = 'flex';
        miniReplayButton.style.justifyContent = 'center';
        miniReplayButton.style.alignItems = 'center';
        miniReplayButton.style.fontSize = '24px';
        miniReplayButton.style.color = 'white';
        miniReplayButton.style.zIndex = '2000';
        miniReplayButton.innerHTML = '↻'; // Symbole de rafraîchissement
        miniReplayButton.style.cursor = 'pointer';
        
        // Ajouter l'événement click/touch
        miniReplayButton.addEventListener('click', restartGame);
        miniReplayButton.addEventListener('touchstart', function(e) {
            e.preventDefault();
            restartGame();
        });
        
        document.body.appendChild(miniReplayButton);
    }
}, 600); // Légèrement après l'affichage de l'écran game over
}
        
        // Fonction pour mettre à jour les meilleurs scores
function updateHighScores() {
    // Ajouter le score actuel à la liste seulement s'il est > 0
    if (score > 0) {
        highScores.push(score);
    }
    
    // Trier par ordre décroissant
    highScores.sort((a, b) => b - a);
    
    // Garder seulement les 5 meilleurs
    highScores = highScores.slice(0, 5);
    
    // S'assurer qu'il y a au moins 5 entrées pour l'affichage
    while (highScores.length < 5) {
        highScores.push(0);
    }
    
    // Sauvegarder dans le localStorage
    try {
        localStorage.setItem('wayowayoHighScores', JSON.stringify(highScores));
    } catch (e) {
        console.error("Erreur lors de la sauvegarde des scores:", e);
    }
}
        
        // Fonction pour partager le score sur les réseaux sociaux ou par message
function shareScore(platform) {
    const shareText = `Je viens de faire ${score} points dans Samoussa Runner sur le site du restaurant WAYOWAYO! Niveau atteint: ${difficultyLevel}, Meilleur combo: x${maxCombo}. Venez battre mon record!`;
    const shareUrl = 'https://lewayowayo.github.io/samoussa-runner/';
    let fullUrl = '';
    
    switch(platform) {
        case 'x':
            fullUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}`;
            break;
        case 'whatsapp':
            fullUrl = `https://wa.me/?text=${encodeURIComponent(shareText + ' ' + shareUrl)}`;
            break;
        case 'sms':
            if (isMobile) {
                fullUrl = `sms:?&body=${encodeURIComponent(shareText + ' ' + shareUrl)}`;
            } else {
                alert("Le partage par SMS n'est disponible que sur mobile.");
                return;
            }
            break;
    }
    
    if (fullUrl) {
        window.open(fullUrl, '_blank');
    }
}
        
        // Système de combo
        function incrementCombo() {
            comboCount++;
            comboMultiplier = Math.min(comboCount + 1, 5); // Maximum x5 multiplicateur
            
            // Mettre à jour l'affichage du combo
            const comboContainer = document.getElementById('combo-container');
            const comboCountElement = document.getElementById('combo-count');
            
            comboContainer.style.display = 'block';
            comboCountElement.textContent = `x${comboMultiplier}`;
            
            // Effet visuel de pulsation
            comboContainer.classList.remove('combo-pulse');
            void comboContainer.offsetWidth; // Force reflow
            comboContainer.classList.add('combo-pulse');
            
            // Mise à jour de la couleur en fonction du niveau de combo
            if (comboMultiplier >= 3) {
                comboContainer.style.color = '#FFD700'; // Or pour les combos élevés
                comboContainer.style.textShadow = '0 0 5px #FFD700';
            } else {
                comboContainer.style.color = '#ff6b6b'; // Couleur normale
                comboContainer.style.textShadow = 'none';
            }
            
            // Mettre à jour le combo maximum
            if (comboMultiplier > maxCombo) {
                maxCombo = comboMultiplier;
            }
        }
        
        function resetCombo() {
            comboCount = 0;
            comboMultiplier = 1;
            
            // Masquer l'affichage du combo
            document.getElementById('combo-container').style.display = 'none';
        }
        
        // Désactiver le double-tap qui pourrait causer un zoom sur mobile
        document.addEventListener('touchend', function(e) {
            if (isGameStarted) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
    <script src="register-sw.js"></script>
    <script src="audio.js"></script>
    <script src="pwa-prompt.js"></script>
    <script>
// Ajustement automatique de la qualité du jeu en fonction des performances
function optimizeGamePerformance() {
    // Détecter si nous sommes sur un appareil Android
    const isAndroid = /Android/i.test(navigator.userAgent);
    // Détecter si nous sommes dans un navigateur (pas en PWA)
    const isPWA = window.matchMedia('(display-mode: standalone)').matches;
    
    // Si nous sommes sur Android dans un navigateur
    if (isAndroid && !isPWA) {
        console.log("Optimisation pour Android en mode navigateur");
        
        // 1. Réduire la fréquence des nuages et des oiseaux
        if (window.gameIntervals && window.gameIntervals.pailleEnQueue) {
            clearInterval(window.gameIntervals.pailleEnQueue);
            window.gameIntervals.pailleEnQueue = setInterval(() => {
                if (!isGameOver) {
                    createPailleEnQueue();
                }
            }, 25000); // Augmenté de 15000ms à 25000ms
        }
        
        // 2. Simplifier les effets visuels
        document.querySelector('.boost-effect').style.display = 'none';
        
        // 3. Optimiser les animations CSS
        const styleSheet = document.createElement('style');
        styleSheet.textContent = `
            @media screen and (-webkit-min-device-pixel-ratio:0) {
                .cloud, .paille-en-queue {
                    will-change: transform;
                    transform: translateZ(0);
                }
                
                .cocotier-feuille {
                    backface-visibility: hidden;
                }
                
                @keyframes float-cloud {
                    0% { transform: translateX(120%) translateZ(0); }
                    100% { transform: translateX(-120%) translateZ(0); }
                }
            }
        `;
        document.head.appendChild(styleSheet);
        
        // 4. Réduire la complexité graphique si nécessaire
        if (window.devicePixelRatio > 2) {
            // Pour les écrans à très haute résolution
            const metaViewport = document.querySelector('meta[name=viewport]');
            if (metaViewport) {
                metaViewport.setAttribute('content', 'width=device-width, initial-scale=0.7, maximum-scale=0.7, user-scalable=no');
            }
        }
    }
}

// Appeler cette fonction au démarrage du jeu
document.addEventListener('DOMContentLoaded', function() {
    // Attendre que le jeu soit complètement chargé
    setTimeout(optimizeGamePerformance, 1000);
});
</script>
    <div id="pwa-prompt" class="overlay-screen" style="display: none;">
    <div class="logo-container">
        <img src="assets/ww.png" alt="WAYOWAYO" style="width: 60%; max-width: 200px;" />
    </div>
    <h2>Pour une meilleure expérience</h2>
    <p>Ce jeu fonctionne mieux quand il est installé sur votre écran d'accueil !</p>
    
    <div style="background-color: rgba(0, 0, 0, 0.2); padding: 15px; border-radius: 10px; margin: 20px 0;">
        <p style="font-weight: bold; color: #FFD700;">Comment installer :</p>
        
        <div id="android-install" style="display: none;">
            <p>1. Appuyez sur <strong>⋮</strong> (menu)</p>
            <p>2. Choisissez <strong>Ajouter à l'écran d'accueil</strong></p>
        </div>
        
        <div id="ios-install" style="display: none;">
            <p>1. Appuyez sur <img src="assets/share-icon.png" style="width: 20px; vertical-align: middle;"> (partager)</p>
            <p>2. Faites défiler jusqu'à <strong>Sur l'écran d'accueil</strong></p>
        </div>
    </div>
    
    <button class="btn" id="continue-browser">CONTINUER QUAND MÊME</button>
    <p style="color: #FF9800; margin-top: 15px; font-size: 0.8em;">Le jeu peut être lent dans certains navigateurs</p>
</div>
    <script>
// Solution stricte pour la faille de sécurité
document.addEventListener('visibilitychange', function() {
    // Si le jeu est en cours et que la page devient cachée
    if (document.hidden && typeof isGameStarted !== 'undefined' && isGameStarted && !isGameOver) {
        console.log("Changement d'onglet détecté - Arrêt du jeu");
        
        // Forcer la fin du jeu
        gameOver();
        
        // Créer un message spécial de game over
        const gameOverScreen = document.getElementById('game-over');
        if (gameOverScreen) {
            // Rechercher le titre h2 du game over
            const h2Elements = gameOverScreen.getElementsByTagName('h2');
            if (h2Elements.length > 0) {
                h2Elements[0].textContent = "PARTIE INTERROMPUE";
            }
            
            // Ajouter un message explicatif
            const explanationMessage = document.createElement('p');
            explanationMessage.style.color = '#FF9800';
            explanationMessage.style.fontWeight = 'bold';
            explanationMessage.textContent = "Le jeu s'arrête si vous changez d'onglet ou d'application.";
            
            // Insérer après le titre
            if (h2Elements.length > 0) {
                h2Elements[0].parentNode.insertBefore(explanationMessage, h2Elements[0].nextSibling);
            } else {
                // Insérer au début si pas de titre
                gameOverScreen.insertBefore(explanationMessage, gameOverScreen.firstChild);
            }
        }
    }
});

// Ajouter un gestionnaire pour les changements d'application
window.addEventListener('blur', function() {
    // Si le jeu est en cours et que la fenêtre perd le focus
    if (typeof isGameStarted !== 'undefined' && isGameStarted && !isGameOver) {
        console.log("Changement d'application détecté - Arrêt du jeu");
        gameOver();
    }
});
</script>
    <script>

document.addEventListener('DOMContentLoaded', function() {
    const audioButton = document.getElementById('audio-controls');
    const soundIcon = document.getElementById('sound-icon');
    
    if (audioButton && soundIcon) {
        // Supprimer les gestionnaires existants pour éviter les conflits
        audioButton.replaceWith(audioButton.cloneNode(true));
        
        // Récupérer la référence au nouvel élément cloné
        const newAudioButton = document.getElementById('audio-controls');
        const newSoundIcon = document.getElementById('sound-icon');
        
        function toggleAudio(e) {
    // Arrêter la propagation et l'action par défaut
    e.preventDefault();
    e.stopPropagation();
    
    console.log("Bouton audio cliqué");
    
    if (typeof AudioManager !== 'undefined') {
        // Mémoriser l'état actuel avant de le changer
        const wasMuted = AudioManager.isMuted;
        
        // Utiliser la fonction toggleMute d'AudioManager
        const isMuted = AudioManager.toggleMute();
        
        // Mettre à jour l'icône
        newSoundIcon.src = isMuted ? 'assets/sound-off.png' : 'assets/sound-on.png';
        newSoundIcon.alt = isMuted ? 'Son désactivé' : 'Son activé';
        
        console.log("Son " + (isMuted ? "désactivé" : "activé"));
        
        // Si on vient de réactiver le son (était muet, n'est plus muet)
        if (wasMuted && !isMuted) {
            // Petit délai pour laisser AudioManager terminer ses opérations
            setTimeout(() => {
                if (AudioManager.currentMusicPath) {
                    console.log("Relance forcée de la musique de fond");
                    AudioManager.playMusic(AudioManager.currentMusicPath);
                }
            }, 100);
        }
    } else {
        console.error("AudioManager non trouvé");
    }
    
    return false;
}
        
        // Ajouter des gestionnaires pour différents types d'événements
        newAudioButton.addEventListener('click', toggleAudio);
        newAudioButton.addEventListener('touchstart', toggleAudio, { passive: false });
        
        // Ajouter un effet visuel au toucher
        newAudioButton.addEventListener('touchstart', function() {
            this.style.opacity = '0.7';
        }, { passive: true });
        
        newAudioButton.addEventListener('touchend', function() {
            this.style.opacity = '1';
            // Ne pas appeler toggleAudio ici car touchstart le fera déjà
        }, { passive: true });
        
        console.log("Gestionnaire audio amélioré installé");
    }
});
</script>
    <script>
// Détecter Safari et afficher le message PWA
document.addEventListener('DOMContentLoaded', function() {
    // Détecter si c'est Safari et pas déjà en mode PWA
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    const isPWA = window.matchMedia('(display-mode: standalone)').matches;
    
    if (isSafari && !isPWA) {
        document.getElementById('safari-pwa-prompt').style.display = 'block';
    }
    
    // Vérifier si le bouton REJOUER est visible
    const checkButtonVisibility = function() {
        const button = document.getElementById('restart-button');
        const rect = button.getBoundingClientRect();
        
        // Si le bouton est partiellement hors écran
        if (rect.bottom > window.innerHeight) {
            // Ajuster le padding du game-over pour s'assurer que tout est visible
            const gameOver = document.getElementById('game-over');
            const currentPadding = parseInt(window.getComputedStyle(gameOver).paddingBottom) || 0;
            gameOver.style.paddingBottom = (currentPadding + 20) + 'px';
        }
    };
    
    // Vérifier la visibilité quand l'écran game-over s'affiche
    const gameOverScreen = document.getElementById('game-over');
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.attributeName === 'style' && 
                gameOverScreen.style.display !== 'none') {
                setTimeout(checkButtonVisibility, 100);
            }
        });
    });
    
    observer.observe(gameOverScreen, { attributes: true });
});
</script>
</body>
</html>
